// eslint-disable-next-line @typescript-eslint/no-var-requires
const uuid = require('uuid');

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface) {
    try {
      await queryInterface.bulkInsert('posts', [
        {
          id: uuid.v4(),
          language: 'en',
          title: 'How does DNS work and why we need DNSSEC',
          slug: 'how-does-dns-work-and-why-we-need-dnssec',
          tags: 'mikhail,bahdashych,mikhail bahdashych,blog,dns,dnssec',
          type: ['theory'],
          description: 'Have you ever heard about DNS? I bet you have! Also I bet that if you tried to figure out what this is all about you have seen DNSSEC. Well... it\'s time to figure out how deep this rabbit hole actually is...',
          page_description: 'I guess all you guys have ever heard about DNS. This is phone book of the Internet, and it converts human-readable domain names into IP addresses parsed by machines and blah-blah-blah. Honestly, this is literally rabbit hole, and I have decided to figure out how deep it is. Well, trust me, you are going to be surprised and I have hella interesting stuff to share with you. So, let\'s dive into it!',
          search_tags: ['dns', 'dnssec'],
          intro: 'Rabbit hole — I guess this is the best description I found for DNS. I was enough naive to think that the only thing it does is converting domain names to IP address to ensure that human-readable names are understood by machines. I have no clue how wrong I was thinking that way.',
          footer: 'Phew... That was kinda complicated, wasn\'t it? But now you what DNS and DNSSEC actually are and how they work. If after reading you have even more questions than before, congratulations, from now on you will be able to find all answers on your own, but that\'s it for now. Thank you so much for reading.',
          toc: "{\"intro\":\"Introduction\",\"DNS Overview\":{\"terminology\":\"DNS Terminology\",\"resolutionFlow\":\"DNS Resolution Flow\",\"DNS Servers Roles and Complete Lookup\":{\"stubResolver\":\"DNS Stub Resolver\",\"recursiveResolver\":\"DNS Recursive Resolver\",\"rootNameserver\":\"DNS Root Nameserver\",\"tldNameserver\":\"DNS TLD Nameserver\",\"authNameserver\":\"DNS Authoritative Nameserver\",\"rootNameserverVsRootServer\":\"DNS Root Nameserver vs DNS Root Server\"},\"DNS Records Types\":{\"aRec\":\"A Record (address)\",\"quadA\":\"AAAA Record (quad A)\",\"mxRec\":\"MX Record (Mail eXchange)\",\"nsRec\":\"NS Record (nameserver)\",\"cnameRec\":\"CNAME Record (Canonical Name)\",\"anameRec\":\"ANAME Record\",\"txtRec\":\"TXT Record\"}},\"dnsSecIssues\":\"DNS Security Issues\",\"DNSSEC Overview\":{\"terminology\":\"DNSSEC Terminology\",\"resolutionFlow\":\"DNSSEC Resolution Flow\"},\"dnssecSignCeremony\":\"The DNSSEC Root Signing Ceremony\",\"About DNS Encryption\":{\"dot\":\"DNS over TLS\",\"doh\":\"DNS over HTTPS\",\"difference\":\"Difference between DoT and DoH\"},\"conclusion\":\"Conclusions\",\"references\":\"Contact and references\"}",
          content: "[{\"type\":\"title\",\"content\":\"Introduction\"},{\"type\":\"paragraph\",\"content\":\"In today\'s digital age, the Domain Name System (DNS) plays a vital role in facilitating online communication and enabling users to access websites and services on the internet. However, with the increasing number of cybersecurity threats and malicious activities, there is a growing concern about the security of DNS and the potential risks associated with it.\"},{\"type\":\"paragraph\",\"content\":\"This is where DNS Security Extensions (DNSSEC) comes into the picture, offering a powerful solution to strengthen the security of DNS and protect against various attacks such as DNS spoofing, cache poisoning, and other forms of cyber threats.\"},{\"type\":\"paragraph\",\"content\":\"In this blog post, we\'ll take a closer look at what DNS and DNSSEC are, how they work, and why they are essential for maintaining a secure and reliable internet infrastructure. We\'ll also explore some real-world use cases and discuss the benefits and limitations of DNSSEC. So, if you want to learn more about DNS and DNSSEC and how they can help secure your online presence, keep reading!\"},{\"type\":\"title\",\"content\":\"DNS Overview\"},{\"type\":\"paragraph\",\"content\":\"The same as always let\'s start with short description what DNS actually is and how it can be described. The most popular definition of DNS always sounds more or less like that:\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS (Domain Name System)</b> — system that translates human-readable domain names to IP address, so machines can communicate with each other using those IP addresses.\"]},{\"type\":\"paragraph\",\"content\":\"Sounds pretty common, isn\'t it? I wanted to try to dig a little deeper in order to find out what happens after you write URL address into your browser and hit Enter button. I wanted to know what is happening behind the scene and how your computer obtains the IP address of source web server.\"},{\"type\":\"subtitle\",\"content\":\"DNS Terminology\"},{\"type\":\"paragraph\",\"content\":\"But before we start, let\'s define some terminology we are going to use all through our long journey. Feel free to get back to them whenever you need that:\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS Domain / DNS Zone</b> — a section of the DNS namespace. For instance: blog.mikhailbahdashych.me. (trailing dot is not a typo) is the server named \\\"blog\\\" in the \\\"mikhailbahdashych\\\" domain/zone, which is in the \\\"me\\\" domain/zone, which is in the \\\"root (.)\\\" domain/zone.\",\"<b>Iterative DNS Query</b> — a request to a DNS server: \'Give me whatever help you can, but ask no one else\'.\",\"<b>Recursive DNS Query</b> — a request to a DNS server: \'Give me what I need, and ask everyone you want\'.\",\"<b>DNS Server</b> — term that described the whole infrastructure of DNS roles. It\'s okay, if you don\'t understand it at this point, we will clarify that.\",\"<b>DNS Query or Request</b> — request for resolution of domain name to an IP address.\"]},{\"type\":\"subtitle\",\"content\":\"DNS Resolution Flow\"},{\"type\":\"paragraph\",\"content\":\"The very first thing we need to know about is: how does your browser send some text in form of URL and get back IP address of requested website? At this moment of time we are discussing DNS only from perspective that the only thing it does is converting URLs into IP address of websites, but we will expand its usage a little later.\"},{\"type\":\"paragraph\",\"content\":\"Here is where <b>DNS Resolution Flow</b> comes into play. Everything is better on examples, so let\'s say you want to request for <b>cloudflare.com. (trailing dot is not a typo)</b>. First of all let me just introduce you the sequence of all requests, the whole resolution flow itself, and then we discuss its parts step-by-step:\"},{\"type\":\"list-numeric\",\"items\":[\"The client sends a recursive query to its local recursive caching DNS server for IP address of <b>\\\"cloudflare.com\\\"</b> webpage.\",\"The recursive caching DNS server sends an iterative query to a root (<b>\\\".\\\"</b>) nameserver for IP address of <b>\\\"cloudflare.com\\\"</b> webpage.\",\"The root nameserver responds with a referral to <b>\\\".com\\\"</b> zone\'s TLD nameserver.\",\"The recursive caching DNS server sends an iterative query to a <b>\\\".com\\\"</b> TLD nameserver for IP address of <b>\\\"cloudflare.com\\\"</b> webpage.\",\"The <b>\\\".com\\\"</b> TLD nameserver responds with a referral to <b>\\\"cloudflare\\\"</b> zone\'s authoritative nameserver.\",\"The recursive caching DNS server sends an iterative query to a <b>\\\"cloudflare\\\"</b> authoritative nameserver for IP address of <b>\\\"cloudflare.com\\\"</b> webpage.\",\"The <b>\\\"cloudflare\\\"</b> authoritative nameserver server responds with the IP address for <b>\\\"cloudflare.com\\\"</b>. webpage\",\"The recursive caching DNS server responds to the original client with the IP address of <b>\\\"cloudflare.com\\\"</b> (and caches it, if it had no this record).\",\"The client interacts with the web server <b>\\\"cloudflare.com\\\"</b>.\"]},{\"type\":\"picture\",\"width\":\"w80\",\"resource\":\"dns_record_request_sequence_recursive_resolver.png\"},{\"type\":\"paragraph\",\"content\":\"Okay, smart ass, but about about subdomains, like for example <b>\\\"blog.cloudflare.com\\\"</b>? Not a big deal, the sequence will be expand for one more authoritative nameserver, which holds the IP address of that subdomain.\"},{\"type\":\"picture\",\"width\":\"w80\",\"resource\":\"dns_record_request_sequence_cname_subdomain.png\"},{\"type\":\"paragraph\",\"content\":\"Well, well, well, I see you have a lot questions. Okay, let\'s break this sequence down with step-by-step explanations of different types of nameservers. It\'s time to figure out everything about <b>DNS Servers Roles and Complete Lookup</b>.\"},{\"type\":\"subtitle\",\"content\":\"DNS Servers Roles and Complete Lookup\"},{\"type\":\"paragraph\",\"content\":\"The first thing you need to understand is that all those nameservers like root, TLD and blah-blah-blah are just roles. It literally can be just one physical machine (eiter virtual or not) which is responsible for handling almost every step of described sequence above. Also, I guess you have already notices, that there is some <b>hierarchy</b> of DNS servers, and that\'s true. All DNS roles are places in hierarchy that goes up from down.\"},{\"type\":\"paragraph\",\"content\":\"By the way, <b>let\'s consider that there is no caching on each step of the sequence</b>. You should know that <b>caching</b> is probably one of the most important function of the whole DNS. We want to make as few requests as possible in order to keep high performance of the system. Caching there is on literally every step of the DNS resolution flow.\"},{\"type\":\"paragraph\",\"content\":\"Also, let\'s update our sequence a little and let me introduce the whole <b>DNS lookup flow</b>. Just keep in mind this picture and get back to it after you read about each role to complete this pictuer inside your head and understand each step and role for the DNS lookup.\"},{\"type\":\"picture\",\"width\":\"w100\",\"resource\":\"what_is_a_dns_server_dns_lookup.png\"},{\"type\":\"paragraph\",\"content\":\"So, the very first thing that your DNS query meets is <b>DNS Stub Resolver</b>.\"},{\"type\":\"subsubtitle\",\"content\":\"DNS Stub Resolver\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS Stub Resolver</b> — is an intermediate component between application that requiring DNS resolution and recursive DNS resolver. A DNS stub resolver is typically used by end-user devices, such as laptops, smartphones, and other networked devices, to look up domain names for websites and other online services.\"]},{\"type\":\"paragraph\",\"content\":\"The operating system level DNS resolver is the second and last local stop before a DNS query leaves your machine. The process inside your operating system that is designed to handle this query is commonly called a <b>\\\"stub resolver\\\"</b> or <b>DNS client</b>. When a stub resolver gets a request from an application, it first checks its own cache to see if it has the record. If it does not, it then sends a DNS query (with a recursive flag set), outside the local network to a DNS recursive resolver inside the Internet service provider (ISP).\"},{\"type\":\"paragraph\",\"content\":\"I guess you have notices that there is no stub resolver on pictures, but that\'s fine. It\'s step between client and DNS recursive resolver. Basically, this is step where client checks if it already has the cached IP address of requested domain name. Also, for better understanding let\'s mark all steps where this role is involved. So, let\'s say it is <b>step 0</b>.\"},{\"type\":\"subsubtitle\",\"content\":\"DNS Recursive Resolver\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS Recursive Resolver</b> — the recursive resolver is a component responsible for responses to a recursive request from a client and taking the time to track down the DNS record (usually 24h). It performs the task of resolving DNS queries by recursively traversing the DNS hierarchy. When a recursive resolver receives a DNS query from a client, it will query other DNS servers on behalf of the client to resolve the domain name to an IP address.\"]},{\"type\":\"paragraph\",\"content\":\"<b>DNS Recursive Resolver is the connecting link of the whole flow.</b>\"},{\"type\":\"paragraph\",\"content\":\"One of the key benefits of using a recursive resolver is that it can <b>cache</b> DNS records to improve the efficiency of subsequent DNS queries. This is why also going to refer to it as to <b>DNS caching server</b>. When a recursive resolver receives a DNS response, it will store the response in its cache for a period of time (known as the time-to-live, or TTL), so that it can quickly respond to future queries for the same domain name. This can help to reduce the load on the DNS system and improve the performance of DNS lookups.\"},{\"type\":\"paragraph\",\"content\":\"Here is where everything starts. The client (end user) sends a recursive query to its local recursive caching DNS server for <b>cloudflare.com</b>. This is <b>step 1</b>\"},{\"type\":\"subsubtitle\",\"content\":\"DNS Root Nameserver\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS Root Nameserver</b> — the root nameserver <b>(DNS Root Nameserver ≠ DNS Root Server!!! We\'ll discuss that later)</b> is the first step in translating (resolving) human-readable host names into IP addresses. Remember that dot in domain name, that wasn\'t typo? This is where root nameserver comes into play.\"]},{\"type\":\"paragraph\",\"content\":\"The recursive caching server sends an iterative query to a root <b>\\\".\\\"</b> nameserver for <b>cloudflare.com</b> — <b>step 2</b>. The root nameserver responds with referral to <b>\\\".com\\\"</b> zone\'s nameserver. But what is <b>\\\".com\\\"</b>, of course, it\'s top-level domain! The root server responds with a referral to <b>\\\".com\\\"</b> zone\'s TLD nameservers.\"},{\"type\":\"subsubtitle\",\"content\":\"DNS TLD Nameserver\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS TLD Nameserver</b> — TLD stands for top-level domain. TLD nameserver maintains information for all the domain names that share a common domain extension, such as <b>.com</b, <b>.net</b>, or whatever comes after the last dot in a URL. For example, a <b>\\\".com\\\"</b> TLD nameserver contains information for every website that ends in <b>\\\".com\\\"</b>.\"]},{\"type\":\"paragraph\",\"content\":\"The recursive caching DNS server sends an iterative query to a <b>\\\".com\\\"</b> server for cloudflare.com — <b>step 4</b>. TLD Nameserver responds with a referral to cloudflare zone\'s authoritative nameserver — <b>step 5</b>.\"},{\"type\":\"subsubtitle\",\"content\":\"DNS Authoritative Nameserver\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS Authoritative Nameserver</b> — this final nameserver can be thought of as a dictionary on a rack of books, in which a specific name can be translated into its definition. The authoritative nameserver is the last stop in the nameserver query. If the authoritative nameserver has access to the requested record, it will return the IP address for the requested hostname back to the DNS Recursor that made the initial request.\"]},{\"type\":\"paragraph\",\"content\":\"The recursive caching DNS server sends an iterative query to a <b>\\\"cloudflare\\\"</b> server for <b>\\\"cloudflare.com\\\"</b> — <b>step 6</b>. The <b>\\\"cloudflare.com\\\"</b> authoritative nameserver responds with the IP address for <b>\\\"cloudflare.com\\\"</b> — <b>step 7</b>. The recursive caching DNS server responds to the original client with the IP address of <b>\\\"cloudflare.com\\\"</b> — <b>step 8</b> — and client interacts with the web server <b>\\\"cloudflare.com\\\"</b> — <b>steps 9 and 10</b>.\"},{\"type\":\"paragraph\",\"content\":\"Well done, that\'s it about DNS lookups. Now you know how it works and what components are involved. Probably you have noticed that there are a lot of \\\"DNS Servers\\\". When I say \\\"DNS server\\\" I literally mean this whole flow because DNS server just combines inside all roles.\"},{\"type\":\"subsubtitle\",\"content\":\"DNS Root Nameserver vs DNS Root Server\"},{\"type\":\"paragraph\",\"content\":\"Remember that pictured titled <b>Complete DNS Lookup and Webpage Query</b>. There is one huge mistake on that picture. You see, step 2 and 3 tell about about communication with <b>DNS Root Server</b>, but in reality, it\'s <b>DNS Root Nameserver</b>. It is extremely important to differ them. So, let me explain the difference:\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS Root Servers</b> — are the 13 authoritative name servers that are responsible for responding to queries for the root zone of the Domain Name System (DNS). These servers are operated by various organizations around the world and are identified by letters A through M. They are the first step in the process of resolving a domain name to an IP address and help to direct traffic to the appropriate top-level domain (TLD) nameserver.\",\"<b>DNS Root Nameservers</b> — set of nameservers that serve the root zone of the DNS. These nameservers are responsible for providing referrals to the TLD nameservers and other authoritative nameservers, and they play a critical role in the functioning of the DNS. The term \\\"root nameserver\\\" is often used interchangeably with \\\"root server,\\\" but strictly speaking, the former refers specifically to the nameservers that serve the root zone.\"]},{\"type\":\"subtitle\",\"content\":\"DNS Records Types\"},{\"type\":\"paragraph\",\"content\":\"At the beginning of our path I told that until some point of time we should consider DNS as something converting URLs into IP address of websites. Technically, this is true, but only partly. DNS is responsible for converting <b>every human-readable resource name into IP address</b>. It not only includes websites (IPv4 and IPv6), but also email servers, for instance. Those are called <b>DNS records types</b>. Let\'s briefly discuss most important of them.\"},{\"type\":\"subsubtitle\",\"content\":\"A Record (address)\"},{\"type\":\"list-bullet\",\"items\":[\"<b>A Record (address)</b> — shows the IP address for a specific hostname or domain. Works for IPv4 type only. The main usage of it is for IP address lookup. Using an A record, a web browser is able to load a website using the domain name.\"]},{\"type\":\"subsubtitle\",\"content\":\"AAAA Record (quad A)\"},{\"type\":\"list-bullet\",\"items\":[\"<b>AAAA Record (quad A)</b> — just like A record points to the IP address for a domain, buy instead of using IPv4, uses IPv6. The main usage of if is the same as for A type, but resolving a domain name to the newer IPv6 protocol address. Mobile phones prefer IPv6, if it\'s available.\"]},{\"type\":\"subsubtitle\",\"content\":\"MX Record (Mail eXchange)\"},{\"type\":\"list-bullet\",\"items\":[\"<b>MX Record (Mail eXchange)</b> — makes possible to direct emails to a mail server by showing where emails for a domain should be routed to. You can have multiple MX records for a single domain name — basically, just backup email severs. The lower priority value for the server, the more important it is. And in case when primary server goes down, the secondary server will be used - active-active scheme.\"]},{\"type\":\"paragraph\",\"content\":\"The main usage of it is to map where email should be delivered. Should point to a mail server name and not to an IP address. <b>ANAME</b> — can point to a mail server name or an IP address.\"},{\"type\":\"subsubtitle\",\"content\":\"NS Record (nameserver)\"},{\"type\":\"list-bullet\",\"items\":[\"<b>NS Record (nameserver)</b> — specifies the authoritative DNS server for a domain. In other words, the NS record helps point to where internet application like a web browser can find the IP address for a domain name. Usually, multiple nameservers are specified for a domain. The main usage of those authoritative servers is to connect your domain name to the actual server your site is hosted on. The nameservers contains other DNS records like MX or A records.\"]},{\"type\":\"subsubtitle\",\"content\":\"CNAME Record (Canonical Name)\"},{\"type\":\"list-bullet\",\"items\":[\"<b>CNAME record (Canonical Name)</b> — is a DNS records that points a domain name (an alias) to another domain. In a CNAME record, the alias doesn\'t point to an IP address. And the domain name that the alias points to is the canonical name.\"]},{\"type\":\"paragraph\",\"content\":\"For example, the subdomain ng.example.com (ng.example.com is a CNAME Record) can point to example.com using CNAME. Here example.com points to the actual IP address using an A record.\"},{\"type\":\"paragraph\",\"content\":\"The main usage of it is running multiple subdomains for different purposes on the same server. For example, we have ftp.example.com and www.example.com. We can then use a CNAME record to point both subdomains to example.com. The main domain example.com then points to the server\'s IP address using an A record. It\'s also possible for one CNAME to point to other CNAME. However, doing so is inefficient and can lead to slow load speed and poor user experience.\"},{\"type\":\"paragraph\",\"content\":\"Usually points to a load balancer.\"},{\"type\":\"subsubtitle\",\"content\":\"ANAME Record\"},{\"type\":\"list-bullet\",\"items\":[\"<b>ANAME (ALIAS)</b> — combination of CNAME and A types of records. ANAME is not a read DNS record but a way of simulating it. And that\'s why it is called Alias name. Just like CNAME, ANAME maps one domain name to another. So, an ANAME is configured to point to another domain. When the domain name an ANAME points to is queried by the client browser, it responds with an IP address. A CNAME, on the other hand, cannot point to an IP address, but an ANAME can.\"]},{\"type\":\"paragraph\",\"content\":\"Was used in the past, CNAME is a king nowadays. Shouldn\'t point to a load balancer.\"},{\"type\":\"subsubtitle\",\"content\":\"TXT Record\"},{\"type\":\"list-bullet\",\"items\":[\"<b>TXT Record (Text Record)</b> — is the type of record that allows administrator to add human-readable (and machine-readable) notes in the DNS. Doesn\'t require specific format. Used to provide the ability to associate arbitrary text with a host or other name, such as human readable information about a server, network, data center, or other accounting information\"]},{\"type\":\"paragraph\",\"content\":\"The main usage of it nowadays is to prevent email spam and verify domain ownership. Here we should talk about DMARC, SPF and DKIM, but for now just know that those are about <b>anti-spam security</b>.\"},{\"type\":\"title\",\"content\":\"DNS Security Issues\"},{\"type\":\"paragraph\",\"content\":\"Okay, now we have a complete overview of how DNS resolution works, what are different roles of DNS servers and even mentioned a couple of main record types, but what about security issues? Actually, we have only 2 main security issues — <b>lack of authentication and confidentiality</b>.\"},{\"type\":\"paragraph\",\"content\":\"The first is due to the fact that DNS has no ability to check if the record it has requested comes from trusted source, and this issue is mitigated by <b>DNSSEC</b>.\"},{\"type\":\"paragraph\",\"content\":\"The second is due to the fact that DNS as a protocol has been implemented in early 80\'s. As you already know, at that period of time, security wasn\'t on the foreground while all resources have been concentrated on providing just availability. Therefore, DNS, as many other protocols such as HTTP or ART, is transmitting data in plaintext. This issue is mitigated by <b>encryption</b>.\"},{\"type\":\"paragraph\",\"content\":\"Fine, we are definitely going to discuss both of the issues, but let\'s first take a look at how DNS looks like when it has been hacked:\"},{\"type\":\"list-numeric\",\"items\":[\"The client sends a recursive query to its local recursive caching DNS server for IP address of <b>\\\"cloudflare.com\\\"</b> webpage.\",\"The recursive caching DNS server sends an iterative query to a root (<b>\\\".\\\"</b>) nameserver for IP address of <b>\\\"cloudflare.com\\\"</b> webpage.\",\"The root nameserver responds with a referral to <b>\\\".com\\\"</b> zone\'s TLD nameserver.\",\"The recursive caching DNS server sends an iterative query to a <b>\\\".com\\\"</b> TLD nameserver for IP address of <b>\\\"cloudflare.com\\\"</b> webpage.\",\"The <b>\\\".com\\\"</b> TLD nameserver responds with a referral to <b>\\\"cloudflare\\\"</b> zone\'s authoritative nameserver.\",\"The recursive caching DNS server sends an iterative query to a <b>\\\"cloudflare\\\"</b> authoritative nameserver for IP address of <b>\\\"cloudflare.com\\\"</b> webpage.\",\"The evil DNS server responds with the evil IP address for <b>\\\"cloudflare.com\\\"</b>.\",\"The recursive caching DNS server responds to the original client with the evil IP address for <b>\\\"cloudflare.com\\\"</b>.\",\"Client interacts with the evil web server, which either respond directly, or perform <b>Man-in-the-Middle</b> attack operation by passing and observing (or altering) traffic from/to the legitimate web server.\"]},{\"type\":\"picture\",\"width\":\"w70\",\"resource\":\"dns_poisoning.jpeg\"},{\"type\":\"paragraph\",\"content\":\"As you can see, from step 1 to 6 we have exactly the same flow, problems start from step 7.\"},{\"type\":\"paragraph\",\"content\":\"It\'s called <b>DNS spoofing/cache poisoning</b> — this is an attack where forged DNS data is introduced into a DNS resolver\'s cache, resulting in the resolver returning an incorrect IP address for a domain. Instead of going to the correct website, traffic can be diverted to a malicious machine or anywhere else the attacker desires; often this will be a replica of the original site used for malicious purposes such as distributing malware or collecting login information.\"},{\"type\":\"paragraph\",\"content\":\"So, we need to somehow verify that response comes from trusted source, right? Basically, provide <b>authentication</b> — this is where <b>DNSSEC</b> comes into play.\"},{\"type\":\"title\",\"content\":\"DNSSEC Overview\"},{\"type\":\"paragraph\",\"content\":\"Finally, here we are, DNSSEC! We should consider that DNS and DNSSEC now are like HTTP and HTTPS ~20 years ago. It will be just required to use by everyone in order to provide secure communication. DNSSEC and HTTPS are even similar in some cases.\"},{\"type\":\"paragraph\",\"content\":\"HTTPS provide both <b>authentication</b> and <b>confidentiality</b> using PKI infrastructure of CA\'s (if you are not familiar with <a href=\'https://blog.mikhailbahdashych.me/en/blog/pki-infrastructure-or-how-to-build-your-own-vpn\' class=\'inline-link en\'>see here</a>). <b>Authentication</b> is provided by verifying who was the issuer of the certificate, while <b>confidentiality</b> is provided by encrypting traffic.\"},{\"type\":\"paragraph\",\"content\":\"In case of DNSSEC, it provides only <b>authentication</b>, where DNS encryption provides <b>confidentiality</b>, what was already mentioned above. But getting back to DNSSEC, let\'s start with simple definition of what it actually is:\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNSSEC (DNS Security Extension)</b> — is an authentication mechanism that utilises PKI cryptography to prevent spoofing. With DNSSEC, it\'s not DNS queries and responses themselves are cryptographically signed, but rather DNS data itself signed by the owner of the data.\"]},{\"type\":\"paragraph\",\"content\":\"Remember where we mentioned that DNS has hierarchical structure? The example of DNSSEC will make it even more obvious. Assuming that you are already familiar with PKI and cryptography, we need to introduce a couple of new terms especially for DNSSEC.\"},{\"type\":\"subtitle\",\"content\":\"DNSSEC Terminology\"},{\"type\":\"list-bullet\",\"items\":[\"<b>RRSet - Resource Record Set</b> — the first step towards securing a zone with DNSSEC is to group all the records with the same type into a resource record set (RRset). For example, if you have three AAAA records in your zone on the same label (i.e. label.example.com), they would all be bundled into a single AAAA RRset.\\n\\nIt\'s actually this full RRset that gets digitally signed, opposed to individual DNS records. Of course, this also means that you must request and validate all of the AAAA records from a zone with the same label instead of validating only one of them. In short — <b>a set of records with the same type and same domain/zone</b>.\"]},{\"type\":\"picture\",\"width\":\"w80\",\"resource\":\"diagram-rrsets.svg\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNSKEY</b> — contains a public signing key.\",\"<b>RRSig - Resource Record Signature</b> — a record containing RRSet\'s digital signature.\",\"<b>ZSK - Zone Signing Key</b> — <b>used to sign or verify a domain\'s/zone\'s non-key records (A, AAAA, MX etc.)</b>. In DNSSEC, each zone has a pair of zone-signing keys (ZSK), where the private key signs each RRset in the zone while the public key verifies the signature. To implement DNSSEC, a zone operator uses the private ZSK to create digital signatures for each RRset and stores them as RRSig records in their nameserver.\\n\\nHowever, the RRSig records alone cannot be used by DNS resolvers to verify the signatures. To enable this, the zone operator adds their public ZSK to their nameserver in a DNSKEY record.\\n\\nWhen a DNSSEC resolver requests a record type, the nameserver returns the corresponding RRSig along with the RRset. The resolver can then retrieve the public ZSK from the DNSKEY record on the nameserver. The RRset, RRSig, and public ZSK together can validate the response.\\n\\nTrusting the zone-signing key in the DNSKEY record also means trusting all records in the zone. But if the ZSK is compromised, it is crucial to validate the public ZSK to ensure security.\"]},{\"type\":\"picture\",\"width\":\"w60\",\"resource\":\"diagram-zone-signing-keys-2.svg\"},{\"type\":\"list-bullet\",\"items\":[\"<b>KSK - Key Signing Key</b> — <b>used to sign or verify a domain\'s/zone\'s keys</b>. In addition to the zone-signing key, DNSSEC nameservers utilize a key-signing key (KSK). Similar to how the ZSK provided security for the RRsets in the previous section, the KSK validates the DNSKEY record by signing the public ZSK, thereby generating an RRSIG for the DNSKEY.\\n\\nThe public KSK is also published in a DNSKEY record by the nameserver, just like the public ZSK, which results in the DNSKEY RRSet. Both the public KSK and public ZSK are signed by the private KSK. This enables resolvers to use the public KSK to validate the public ZSK.\"]},{\"type\":\"paragraph\",\"content\":\"Validation for resolvers now looks like this:\"},{\"type\":\"list-numeric\",\"items\":[\"Request the desired <b>RRSet</b>, which also returns the corresponding <b>RRSIG</b> record.\",\"Request the DNSKEY records that contains <b>public ZSK and KSK</b> which also returns the <b>RRSig</b> for the <b>DNSKEY RRSet</b>.\",\"Verify the <b>RRSig</b> of the requested <b>RRSet</b> with the <b>public ZSK</b>.\",\"Verify the <b>RRSig</b> of the <b>DNSKEY RRSet</b> with the <b>public KSK</b>.\"]},{\"type\":\"picture\",\"width\":\"w60\",\"resource\":\"diagram-key-signing-keys-2.svg\"},{\"type\":\"paragraph\",\"content\":\"You have probably already noticed the hierarchical nature of DNS, and this is just the beginning. Regarding KSK, the DNSKEY RRSet and corresponding RRSig records can be cached to avoid excessive requests to DNS name servers.\"},{\"type\":\"paragraph\",\"content\":\"The use of separate zone-signing keys and key-signing keys is aimed at facilitating the replacement of an old or compromised KSK, as we will discuss in the next section. Conversely, changing the ZSK is a simpler process, making it possible to use a smaller ZSK without compromising server security and reducing the amount of data that the server needs to transmit with each response.\"},{\"type\":\"paragraph\",\"content\":\"While we have established trust within our zone, DNS is a hierarchical system, and zones typically operate in conjunction with one another. The key-signing key is signed by itself, which doesn\'t add any extra trust, so we need a means of connecting the trust in our zone with its parent zone.\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DS Record - Delegation of Signing</b> — <b>a record containing the hash/digest of a child domain\'s/zone\'s public KSK (the fingerprint of child\'s public KSK)</b>. In DNSSEC, a delegation signer (DS) record is introduced to transfer trust from a parent zone to a child zone. To accomplish this, the zone operator hashes the public KSK contained in the DNSKEY record and provides it to the parent zone to publish as a DS record.\\n\\nWhenever a resolver is directed to a child zone, the parent zone also provides a DS record. This record enables resolvers to determine if the child zone is DNSSEC-enabled. To validate the public KSK of the zone, the resolver hashes it and compares it to the DS record from the parent zone. If the hash values match, the resolver can safely assume that the public KSK has not been compromised or altered, thereby establishing trust in all the records of the child zone. <b>This is how a chain of trust is established in DNSSEC.</b>\"]},{\"type\":\"picture\",\"width\":\"w50\",\"resource\":\"diagram-delegation-signer-records.svg\"},{\"type\":\"list-bullet\",\"items\":[\"<b>The Chain of Trust</b> — the process of establishing trust within a zone and linking it to its parent zone, requires a mechanism for verifying the authenticity of the DS record. This is accomplished by digitally signing the DS record, similar to any other RRSet, resulting in the existence of a corresponding RRSig in the parent zone. The process of validating this signature is repeated successively, all the way up to the public KSK of the parent zone. To confirm the authenticity of this KSK, it is necessary to check the parent\'s DS record, continuing this process up the Chain of Trust.\"]},{\"type\":\"picture\",\"width\":\"w50\",\"resource\":\"diagram-the-chain-of-trust.svg\"},{\"type\":\"subtitle\",\"content\":\"DNSSEC Resolution Flow\"},{\"type\":\"paragraph\",\"content\":\"Oh, that was tough, wasn\'t it? Okay, enough of this terminology, everything is better seen in examples. We are going to modify our previous DNS resolution flow to make it DNSSEC-enabled.\"},{\"type\":\"list-numeric\",\"items\":[\"The client sends a recursive query to its local recursive caching DNS server for IP address of <b>\\\"cloudflare.com\\\"</b> webpage.\",\"The recursive caching DNS server sends an iterative query to a root (<b>\\\".\\\"</b>) nameserver for IP address of <b>\\\"cloudflare.com\\\"</b> webpage.\",\"The root nameserver:\",[\"Sends a referral:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"A non-secured referral for the authoritative TLD nameserver for the <b>\\\".com\\\"</b > zone\"]},\"Sends a record:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>RRSet of DNSKEY</b> records for the root zone - the root zone\'s <b>public ZSK and public KSK</b>.\",\"<b>RRSig</b> of above record set - signed using the root zone\'s <b>private KSK</b>.\",\"<b>DS record</b> for the <b>\\\".com\\\"</b> zone - the hash/digest/fingerprint of the \\\".com\\\" zone\'s public KSK.\",\"<b>RRSig</b> of above DS record - signed using the root zone\'s private ZSK.\"]}],\"The recursive caching DNS server:\",[\"Verifies the record:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>Root</b> zone\'s <b>DNSKEY RRSet</b> is verified by successfully decrypting the RRSet\'s RRSig using the root zone\'s public KSK.\",\"<b>Root</b> zone\'s DS record for <b>\\\".com\\\"</b> zone is verified by successfully decrypting the record\'s RRSig using the <b>root</b> zone\'s public ZSK.\"]},\"Verifies the zone:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"The recursive caching DNS server already has a trusted copy of the root public KSK which it obtained by means other than the DNS protocol (such as from the server\'s operating system\'s vendor). The root zone is verified by the recursive caching DNS server when the server\'s copy of the root public KSK is found to match that provided to the server by the root DNS server.\"]}],\"The recursive caching DNS server sends an iterative query to a <b>\\\".com\\\"</b> TLD nameserver for <b>\\\"cloudflare.com\\\"</b>.\",\"The <b>\\\".com\\\"</b> TLD nameserver:\",[\"Sends a referral:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"A non-secured referral for <b>\\\"cloudflare\\\"</b> zone\'s authoritative nameserver.\"]},\"Sends the records:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>RRSet of DNSKEY</b> records for the \\\".com\\\" zone - the \\\".com\\\" zone\'s <b>public ZSK and public KSK</b>.\",\"<b>RRSig</b> of above record set - signed using the \\\".com\\\" <b>private KSK</b>.\",\"<b>DS record</b> for the <b>\\\"cloudflare\\\"</b> zone - the hash/digest/fingerprint of the \\\"cloudflare\\\" zone\'s public KSK.\",\"<b>RRSig</b> of above DS record - signed using \\\".com\\\" zone\'s private ZSK.\"]}],\"The recursive caching DNS server:\",[\"Verifies the records:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>\\\".com\\\" DNSKEY RRSet</b> is verified by successfully decrypting the RRSet\'s RRSig using the \\\".com\\\" zone\'s public KSK\",\"<b>\\\".com\\\"</b> zone\'s DS record for <b>\\\"cloudflare\\\"</b> zone is verified by successfully decrypting the record\'s RRSig using the <b>\\\".com\\\"</b> zone\'s public ZSK.\"]},\"Verifies the zone:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"The <b>\\\".com\\\"</b> zone is verified by comparing the hash/digest/fingerprint of the <b>\\\".com\\\"</b> zone\'s public KSK from the <b>\\\".com\\\"</b> zone with the previously obtained DS record from the root zone for the <b>\\\".com\\\"</b> zone.\"]}],\"The recursive caching DNS server sends an iterative query to a \\\"cloudflare\\\" authoritative nameserver for \\\"cloudflare.com\\\"\",\"The \\\"cloudflare\\\" authoritative nameserver server:\",[\"Sends the records:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>RRSet of DNSKEY</b> records for the <b>\\\"cloudflare\\\"</b> zone - the <b>\\\"cloudflare\\\"</b> zone\'s public ZSK and public KSK.\",\"<b>RRSig</b> of above record set - signed using the <b>\\\"cloudflare\\\"</b> private KSK.\",\"<b>RRSet of A records</b> from the <b>\\\"cloudflare\\\"</b> zone.\",\"<b>RRSig</b> of above DS record - signed using <b>\\\"cloudflare\\\"</b> zone\'s private ZSK.\"]}],\"The recursive caching DNS server:\",[\"Verifies the records:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>\\\"cloudflare\\\" DNSKEY RRSet</b> is verified by successfully decrypting the RRSet\'s RRSig using the <b>\\\"cloudflare\\\"</b> zone\'s public KSK.\",\"<b>\\\"cloudflare\\\" A RRSet</b> is verified by successfully decrypting the RRSet\'s RRSig using the <b>\\\"cloudflare\\\"</b> zone\'s public ZSK.\"]},\"Verifies the zone:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"The <b>\\\"cloudflare\\\"</b> zone is verified by comparing the hash/digest/fingerprint of the <b>\\\"cloudflare\\\"</b> zone\'s public KSK from the <b>\\\"cloudflare\\\"</b> zone with the previously obtained DS record from the root zone for the <b>\\\"cloudflare\\\"</b> zone.\"]}],\"The recursive caching DNS server responds to the original client with the IP address of <b>\\\"cloudflare.com\\\"</b>.\",\"The client interacts with the web server <b>\\\"cloudflare.com\\\"</b>.\"]},{\"type\":\"paragraph\",\"content\":\"There is one thing you need to understand. All those examples that are presented here about how DNS works are academic examples. This only happens in sterile, \\\"laboratory\\\" conditions (in this case, if there were no cache anywhere). These concepts are easy enough to understand that they have a place to be, in reality, if you have to configure such a system, then it is literally a few lines of code or a configuration change.\"},{\"type\":\"paragraph\",\"content\":\"Such examples are more likely to be needed by people who design networks and infrastructures of this scale.\"},{\"type\":\"paragraph\",\"content\":\"Speaking of the DNS example itself, different configurations represent different functions. As mentioned above all those recursive resolvers, caching server or root nameservers are just roles, physically, it can be one machine. Therefore, configuration of your DNS server also depends on what you want to build. So, be careful with guidelines you find on the Internet.\"},{\"type\":\"title\",\"content\":\"The DNSSEC Root Signing Ceremony\"},{\"type\":\"paragraph\",\"content\":\"Oh, in fact, in order to understand how everything works, you do not need to know anything about this ceremony, but it looks so cool and sounds so pathetic that I could not help but write about it. <b>Keys to the Internet</b>, not bad, huh?\"},{\"type\":\"paragraph\",\"content\":\"You have probably already paid attention to how this DNS hierarchy goes from bottom to top. In this case, you might have a logical question: What is at the very top?\"},{\"type\":\"paragraph\",\"content\":\"That\'s the purpose of the Root Signing Ceremony—a rigorous procedure around signing the root DNS zone\'s public keying information for the next few months. The private signing key used in this process is quite literally the key to the entire DNSSEC-protected Internet. A public, audited, and tightly controlled ceremony around accessing this key is a necessity for DNSSEC to succeed as a global standard.\"},{\"type\":\"paragraph\",\"content\":\"Just find a video of this ceremony, because it\'s translated online and see where DNSSEC trust comes from.\"},{\"type\":\"title\",\"content\":\"About DNS Encryption\"},{\"type\":\"paragraph\",\"content\":\"As you have already found out, DNSSEC insures only authentication, but it still transfers it in plaintext. Here is where cryptography comes into play, our lovely HTTPS and TLS, which will help us to ensure not only authentication of our traffic, but also its confidentiality.\"},{\"type\":\"subtitle\",\"content\":\"DNS over TLS\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS over TLS (or DoT)</b>, is a standard for encrypting DNS queries to keep them secure and private. DoT uses the same protocol as HTTPS to encrypt and authenticate connection. Normally, DNS works over UDP. What DoT does, it it adds TLS encryption on top of the user datagram protocol (UDP), which is used for DNS queries. Additionally, it ensures that DNS requests and responses are not tampered with or forged via on-path attacks.\"]},{\"type\":\"subtitle\",\"content\":\"DNS over HTTPS\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS over HTTPS (or DoH)</b> is an alternative way to DoT. DNS queries and responses are encrypted, but sent via the HTTP or HTTP/2 protocols instead of directly over UDP. DoH traffic looks like other HTTPS traffic - e.g. normal user-driven interactions with websites and web apps — from a network administrator\'s perspective.\"]},{\"type\":\"paragraph\",\"content\":\"In February 2020, the Mozilla Firefox browser began enabling DoH for U.S. users by default. DNS queries from the Firefox browser are encrypted by DoH and go to either Cloudflare or NextDNS. Several other browsers also support DoH, although it is not turned on by default.\"},{\"type\":\"subtitle\",\"content\":\"Difference between DoT and DoH\"},{\"type\":\"paragraph\",\"content\":\"The main difference between them is <b>what port they use</b>. DoT only uses port 853, while DoH uses 443, which is the port that all other HTTPS traffic uses as well.\"},{\"type\":\"paragraph\",\"content\":\"Because DoT has a dedicated port, anyone with network visibility can see DoT traffic coming and going, even though the requests and responses themselves are encrypted. In contrast, with DoH, DNS queries and responses are camouflaged within other HTTPS traffic, since it all comes and goes from the same port.\"},{\"type\":\"paragraph\",\"content\":\"<b>From a network security standpoint, DoT is arguably better</b>. It gives network administrator the ability to monitor and block DNS queries, which is important for identifying and stopping malicious activity.\"},{\"type\":\"paragraph\",\"content\":\"<b>DoH queries, meanwhile, are hidden in regular HTTPS traffic</b>, meaning they cannot easily be blocked without blocking all other HTTPS traffic as well. However, from a privacy perspective, DoH is arguably preferable. With DoH, DNS queries are hidden within the larger flow of HTTPS traffic. This gives network administrators less visibility but provides users with more privacy.\"},{\"type\":\"title\",\"content\":\"Conclusions\"},{\"type\":\"paragraph\",\"content\":\"In conclusion, DNS (Domain Name System) is a fundamental component of the internet that is used to translate domain names into IP addresses. While DNS is critical for internet connectivity and online services, it is also vulnerable to a range of DNS-based attacks, including cache poisoning and DNS spoofing.\"},{\"type\":\"paragraph\",\"content\":\"To address these security concerns, DNSSEC (Domain Name System Security Extensions) has been developed as a security protocol that adds a layer of cryptographic security to the DNS system. By using digital signatures to verify the authenticity of DNS responses, DNSSEC can help to protect against a range of DNS-related attacks, ensuring the integrity and reliability of the DNS system.\"},{\"type\":\"paragraph\",\"content\":\"While the adoption of DNSSEC has been slow, it is becoming increasingly important as the threat of DNS-based attacks continues to grow. Organizations that rely on online services should consider implementing DNSSEC to protect their online presence, improve the security of their network, and reduce the risk of DNS-based attacks. As the internet continues to evolve, DNS and DNSSEC will remain essential components of the global network, ensuring the reliability and security of online services for years to come.\"},{\"type\":\"title\",\"content\":\"Contact and references\"}]",
          references: "[{\"name\":\"What is DNS by Cloudflare\",\"link\":\"https:\/\/www.cloudflare.com\/en-gb\/learning\/dns\/what-is-dns\/\"},{\"name\":\"What is DNSSEC by Cloudflare (obvious, isn't it?)\",\"link\":\"https:\/\/www.cloudflare.com\/en-gb\/dns\/dnssec\/how-dnssec-works\/\"},{\"name\":\"DNS over TLS vs DNS over HTTPS\",\"link\":\"https:\/\/www.cloudflare.com\/en-gb\/learning\/dns\/dns-over-tls\/\"},{\"name\":\"DNS cache poisoning and spoofing\",\"link\":\"https:\/\/www.cloudflare.com\/en-gb\/learning\/dns\/dns-cache-poisoning\/\"},{\"name\":\"People who hold keys for the Internet\",\"link\":\"https:\/\/www.cloudflare.com\/en-gb\/dns\/dnssec\/root-signing-ceremony\/\"},{\"name\":\"Well-written article by ICANN about what DNSSEC is and why it is important\",\"link\":\"https:\/\/www.icann.org\/resources\/pages\/dnssec-what-is-it-why-important-2019-03-05-en\"},{\"name\":\"Really cool video that explains DNS and DNSSEC resolution flows\",\"link\":\"https:\/\/www.youtube.com\/watch?v=_8M_vuFcdZU\"}]",
          created_at: new Date(),
          updated_at: new Date()
        },
        {
          id: uuid.v4(),
          language: 'ru',
          title: 'Как работает DNS и почему нам нужен DNSSEC',
          slug: 'how-does-dns-work-and-why-we-need-dnssec',
          tags: 'mikhail,bahdashych,mikhail bahdashych,blog,dns,dnssec',
          type: ['theory'],
          description: 'Вы когда-нибудь слышали о DNS? Бьюсь об заклад, вы слышали! Также держу пари, что если вы пытались понять, что это такое, вы видели DNSSEC. Что ж... пришло время выяснить, насколько глубока эта кроличья нора на самом деле...,',
          page_description: 'Думаю, все вы, ребята, когда-либо слышали о DNS. Это телефонная книга Интернета, и она преобразует удобочитаемые доменные имена в IP-адреса, анализируемые машинами, и бла-бла-бла. Честно говоря, это буквально кроличья нора, и я решил выяснить, насколько она глубока. Что ж, поверьте мне, вы будете удивлены, и я могу поделиться с вами чертовски интересным материалом. Итак, давайте углубимся в это!',
          search_tags: ['dns', 'dnssec'],
          intro: 'Кроличья нора — думаю, это лучшее описание DNS, которое я нашел. Я был достаточно наивен, чтобы думать, что единственное, что он делает, — это преобразовывает доменные имена в IP-адреса, чтобы гарантировать, что человекочитаемые имена понятны машинам. Я понятия не имею, как неправильно я думал таким образом.',
          footer: 'Фух... Это было довольно сложно, не так ли? Но теперь вы знаете, что такое DNS и DNSSEC и как они работают. Если после прочтения у вас появилось еще больше вопросов, чем раньше, поздравляю, отныне вы сможете найти все ответы самостоятельно, но пока это все. Большое спасибо за чтение.',
          toc: "{\"intro\":\"Введение\",\"Обзор DNS\":{\"terminology\":\"DNS-терминология\",\"resolutionFlow\":\"Разрешения DNS адресов\",\"Роли DNS-серверов и полный поиск\":{\"stubResolver\":\"Преобразователь DNS-заглушек\",\"recursiveResolver\":\"Рекурсивный преобразователь DNS\",\"rootNameserver\":\"Корневой DNS-сервер имен\",\"tldNameserver\":\"TLD DNS-сервер имен\",\"authNameserver\":\"Авторитетный DNS-сервер имен\",\"rootNameserverVsRootServer\":\"DNS Root Nameserver vs DNS Root Server\"},\"Типы DNS рекордов\":{\"aRec\":\"A Рекорд (address)\",\"quadA\":\"AAAA Рекорд (quad A)\",\"mxRec\":\"MX Рекорд (Mail eXchange)\",\"nsRec\":\"NS Рекорд (nameserver)\",\"cnameRec\":\"CNAME Рекорд (Canonical Name)\",\"anameRec\":\"ANAME Рекорд\",\"txtRec\":\"TXT Рекорд\"}},\"dnsSecIssues\":\"Проблемы безопасности DNS\",\"Обзор DNSSEC\":{\"terminology\":\"Терминология DNSSEC\",\"resolutionFlow\":\"Разрешения DNSSEC адресов\"},\"dnssecSignCeremony\":\"Церемония подписания корневого каталога DNSSEC\",\"О шифровании DNS\":{\"dot\":\"DNS через TLS\",\"doh\":\"DNS через HTTPS\",\"difference\":\"Разница между DoT и DoH\"},\"conclusion\":\"Выводы\",\"references\":\"Контакты и рекомендации\"}",
          content: "[{\"type\":\"title\",\"content\":\"Введение\"},{\"type\":\"paragraph\",\"content\":\"В сегодняшнюю цифровую эпоху система доменных имен (DNS) играет жизненно важную роль в облегчении онлайн-общения и предоставлении пользователям доступа к веб-сайтам и услугам в Интернете. Однако с ростом числа угроз кибербезопасности и злонамеренных действий растет озабоченность по поводу безопасности DNS и связанных с ней потенциальных рисков.\"},{\"type\":\"paragraph\",\"content\":\"Именно здесь на сцену выходят расширения безопасности DNS (DNSSEC), предлагающие мощное решение для усиления безопасности DNS и защиты от различных атак, таких как спуфинг DNS, отравление кеша и другие формы киберугроз.\"},{\"type\":\"paragraph\",\"content\":\"В этом посте мы более подробно рассмотрим, что такое DNS и DNSSEC, как они работают и почему они необходимы для поддержания безопасной и надежной интернет-инфраструктуры. Мы также рассмотрим некоторые примеры использования в реальных условиях и обсудим преимущества и ограничения DNSSEC. Итак, если вы хотите узнать больше о DNS и DNSSEC и о том, как они могут помочь защитить ваше присутствие в Интернете, продолжайте читать!\"},{\"type\":\"title\",\"content\":\"Обзор DNS\"},{\"type\":\"paragraph\",\"content\":\"Как всегда, начнем с краткого описания того, что такое DNS на самом деле и как его можно описать. Самое популярное определение DNS всегда звучит примерно так:\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS (Система Доменных Имен)</b> — система, которая переводит удобочитаемые доменные имена в IP-адреса, чтобы машины могли общаться друг с другом, используя эти IP-адреса.\"]},{\"type\":\"paragraph\",\"content\":\"Звучит довольно обычно, не так ли? Я хотел попытаться копнуть немного глубже, чтобы узнать, что происходит после того, как вы введете URL-адрес в свой браузер и нажмете кнопку Enter. Я хотел знать, что происходит за кулисами и как ваш компьютер получает IP-адрес исходного веб-сервера.\"},{\"type\":\"subtitle\",\"content\":\"DNS-терминология\"},{\"type\":\"paragraph\",\"content\":\"Но прежде чем мы начнем, давайте определимся с терминологией, которую будем использовать на протяжении всего нашего долгого путешествия. Не стесняйтесь обращаться к ней, когда вам это нужно:\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS-домен/DNS-зона</b> — раздел пространства имен DNS. Например: blog.mikhailbahdashych.me. (точка в конце — не опечатка) — это сервер с именем \\\"blog\\\" в  домен/зона \\\"mikhailbahdashych\\\", которая находится в домене/зоне \\\"me\\\", которая находится в \\\"корневом (.)\\\" домене/зоне.\",\"<b>Итеративный DNS-запрос</b> — запрос к DNS-серверу: \\\"Помогите мне, чем можете, но ни у кого больше не спрашивайте\\\".\",\"<b>Рекурсивный DNS-запрос</b> — запрос к DNS-серверу: \\\"Дайте мне то, что мне нужно, и спросите всех, кого хотите\\\".\",\"<b>DNS-сервер</b> — термин, описывающий всю инфраструктуру DNS-ролей. Ничего страшного, если вы не понимаете этого на данный момент, мы это уточним.\",\"<b>DNS-запрос или запрос</b> — запрос на преобразование доменного имени в IP-адрес\"]},{\"type\":\"subtitle\",\"content\":\"Разрешения DNS адресов\"},{\"type\":\"paragraph\",\"content\":\"Самое первое, о чем нам нужно знать, это: как ваш браузер отправляет некоторый текст в виде URL-адреса и возвращает IP-адрес запрошенного веб-сайта? На данный момент мы обсуждаем DNS только с точки зрения того, что единственное, что он делает, — это конвертирует URL-адреса в IP-адреса веб-сайтов, но мы расширим его использование чуть позже.\"},{\"type\":\"paragraph\",\"content\":\"Здесь в игру вступает <b>поток разрешения DNS</b>. На примерах все лучше, допустим, вы хотите запросить <b>cloudflare.com. (точка в конце не опечатка)</b>. Прежде всего позвольте мне представить вам последовательность всех запросов, весь процесс разрешения, а затем мы шаг за шагом обсудим его части:\"},{\"type\":\"list-numeric\",\"items\":[\"Клиент отправляет рекурсивный запрос на свой локальный DNS-сервер рекурсивного кэширования для получения IP-адреса веб-страницы <b>\\\"cloudflare.com\\\"</b>.\",\"DNS-сервер с рекурсивным кэшированием отправляет итеративный запрос корневому (<b>\\\".\\\"</b>) серверу имен IP-адреса веб-страницы <b>\\\"cloudflare.com\\\"</b>.\",\"Корневой сервер имен отвечает ссылкой на сервер имен TLD зоны <b>.com</b>.\",\"DNS-сервер с рекурсивным кэшированием отправляет повторяющийся запрос на сервер доменных имен <b>\\\".com\\\"</b> для получения IP-адреса веб-страницы <b>\\\"cloudflare.com\\\"</b>.\",\"Сервер доменных имен <b>\\\".com\\\"</b> отвечает ссылкой на авторитетный сервер имен зоны <b>\\\"cloudflare\\\"</b>.\",\"DNS-сервер с рекурсивным кэшированием отправляет итеративный запрос полномочному серверу имен <b>\\\"cloudflare\\\"</b> для получения IP-адреса веб-страницы <b>\\\"cloudflare.com\\\"</b>.\",\"Авторитетный сервер имен <b>\\\"cloudflare\\\"</b> возвращает IP-адрес для <b>\\\"cloudflare.com\\\"</b>.\",\"DNS-сервер рекурсивного кэширования отвечает исходному клиенту с IP-адресом <b>\\\"cloudflare.com\\\"</b> (и кэширует его, если у него не было этой записи).\",\"Клиент взаимодействует с веб-сервером <b>\\\"cloudflare.com\\\"</b>.\"]},{\"type\":\"picture\",\"width\":\"w80\",\"resource\":\"dns_record_request_sequence_recursive_resolver.png\"},{\"type\":\"paragraph\",\"content\":\"Ладно, умник, а насчет субдоменов, например, <b>\\\"blog.cloudflare.com\\\"</b>? Ничего страшного, последовательность будет расширена для еще одного авторитетного сервера имен, который содержит IP-адрес этого субдомена.\"},{\"type\":\"picture\",\"width\":\"w80\",\"resource\":\"dns_record_request_sequence_cname_subdomain.png\"},{\"type\":\"paragraph\",\"content\":\"Ну-ну, я вижу, у тебя много вопросов. Хорошо, давайте разберем эту последовательность с пошаговыми объяснениями различных типов серверов имен. Пришло время разобраться во всем, что касается <b>ролей DNS-серверов и полного поиска</b>.\"},{\"type\":\"subtitle\",\"content\":\"Роли DNS-серверов и полный поиск\"},{\"type\":\"paragraph\",\"content\":\"Первое, что вам нужно понять, это то, что все эти серверы имен, такие как root, TLD и бла-бла-бла, — это просто роли. Буквально это может быть только одна физическая машина (виртуальная или нет), которая отвечает за обработку почти каждого шага описанной выше последовательности. Кроме того, я думаю, вы уже заметили, что существует некоторая <b>иерархия</b> DNS-серверов, и это правда. Все роли DNS — это места в иерархии, которая идет снизу вверх.\"},{\"type\":\"paragraph\",\"content\":\"Кстати, <b>будем считать, что кэширования на каждом шаге последовательности нет</b>. Вы должны знать, что <b>кеширование</b>, вероятно, является одной из самых важных функций DNS. Мы хотим делать как можно меньше запросов, чтобы сохранить высокую производительность системы. Кэширование присутствует буквально на каждом этапе процесса разрешения DNS.\"},{\"type\":\"paragraph\",\"content\":\"Кроме того, давайте немного изменим нашу последовательность и позвольте мне представить весь <b>процесс поиска DNS</b>. Просто запомните эту картинку и вернитесь к ней после того, как вы прочитаете о каждой роли, чтобы завершить эту картинку в своей голове и понять каждый шаг и роль для поиска DNS.\"},{\"type\":\"picture\",\"width\":\"w100\",\"resource\":\"what_is_a_dns_server_dns_lookup.png\"},{\"type\":\"paragraph\",\"content\":\"Итак, самое первое, с чем сталкивается ваш DNS-запрос, — это <b>преобразователь заглушек DNS</b>.\"},{\"type\":\"subsubtitle\",\"content\":\"Преобразователь DNS-заглушек\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Резолвер DNS-заглушек</b> — это промежуточный компонент между приложением, требующим разрешения DNS, и рекурсивным распознавателем DNS. Преобразователь заглушек DNS обычно используется устройствами конечных пользователей, такими как ноутбуки, смартфоны и другие сетевые устройства, для поиска доменных имен для веб-сайтов и других онлайн-сервисов.\"]},{\"type\":\"paragraph\",\"content\":\"Преобразователь DNS на уровне операционной системы — это вторая и последняя локальная остановка перед тем, как DNS-запрос покинет вашу машину. Процесс внутри вашей операционной системы, предназначенный для обработки этого запроса, обычно называется <b>\\\"резольвером-заглушкой\\\"</b> или <b>DNS-клиентом</b>. Когда резолвер-заглушка получает запрос от приложения, он сначала проверяет свой собственный кэш, чтобы узнать, есть ли у него запись. Если это не так, он отправляет DNS-запрос (с установленным рекурсивным флагом) за пределы локальной сети рекурсивному преобразователю DNS внутри поставщика услуг Интернета (ISP).\"},{\"type\":\"paragraph\",\"content\":\"Я думаю, вы заметили, что на картинках нет резольвера-заглушки, но это нормально. Это шаг между клиентом и рекурсивным преобразователем DNS. По сути, это шаг, на котором клиент проверяет, есть ли уже кешированный IP-адрес запрошенного доменного имени. Также для лучшего понимания отметим все шаги, где задействована эта роль. Допустим, это <b>шаг 0</b>.\"},{\"type\":\"subsubtitle\",\"content\":\"Рекурсивный преобразователь DNS\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Рекурсивный преобразователь DNS</b> — рекурсивный преобразователь это компонент, отвечающий за ответы на рекурсивный запрос от клиента и требующий времени для отслеживания записи DNS (обычно 24 часа). Он выполняет задачу разрешения DNS-запросов путем рекурсивного обхода иерархии DNS. Когда рекурсивный преобразователь получает DNS-запрос от клиента, он будет запрашивать другие DNS-серверы от имени клиента, чтобы преобразовать доменное имя в IP-адрес.\"]},{\"type\":\"paragraph\",\"content\":\"<b>DNS Recursive Resolver — это связующее звено всего потока.</b>\"},{\"type\":\"paragraph\",\"content\":\"Одним из ключевых преимуществ использования рекурсивного преобразователя является то, что он может <b>кэшировать</b> записи DNS для повышения эффективности последующих DNS-запросов. Вот почему мы также будем называть его <b>сервером кэширования DNS</b>. Когда рекурсивный преобразователь получает ответ DNS, он сохраняет ответ в своем кеше в течение определенного периода времени (известного как время жизни или TTL), чтобы он мог быстро отвечать на будущие запросы для того же доменного имени. . Это может помочь снизить нагрузку на систему DNS и повысить производительность поиска DNS.\"},{\"type\":\"paragraph\",\"content\":\"Здесь все начинается. Клиент (конечный пользователь) отправляет рекурсивный запрос на свой локальный DNS-сервер с рекурсивным кэшированием для <b>cloudflare.com</b>. Это <b>шаг 1</b>.\"},{\"type\":\"subsubtitle\",\"content\":\"Корневой DNS-сервер имен\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Корневой сервер имен DNS</b> — корневой сервер имен <b>(Корневой сервер имен DNS ≠ Корневой сервер DNS!!! Мы обсудим это позже.)</b> — это первый шаг в преобразовании (разрешении) удобочитаемого имена хостов в IP-адреса. Помните ту точку в доменном имени, это была не опечатка? Здесь в игру вступает корневой сервер имен.\"]},{\"type\":\"paragraph\",\"content\":\"Сервер рекурсивного кэширования отправляет повторяющийся запрос корневому серверу имен <b>\\\".\\\"</b> для <b>cloudflare.com</b> — <b>шаг 2</b>. Корневой сервер имен отвечает ссылкой на сервер имен зоны <b>\\\".com\\\"</b>. Но что такое <b>\\\".com\\\"</b>, конечно, это домен верхнего уровня! Корневой сервер отвечает ссылкой на серверы имен TLD зоны <b>\\\".com\\\"</b>.\"},{\"type\":\"subsubtitle\",\"content\":\"TLD DNS-сервер имен\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS TLD Nameserver</b> — TLD означает домен верхнего уровня. Сервер имен TLD хранит информацию обо всех доменных именах, имеющих общее расширение домена, например <b>\\\".com\\\"</b, <b>\\\".net\\\"</b> или любое другое имя, которое следует за последней точкой в URL-адресе. Например, сервер доменных имен <b>\\\".com\\\"</b> содержит информацию о каждом веб-сайте, оканчивающемся на <b>\\\".com\\\"</b>.\"]},{\"type\":\"paragraph\",\"content\":\"DNS-сервер рекурсивного кэширования отправляет повторяющийся запрос на сервер <b>\\\".com\\\"</b> для cloudflare.com — <b>шаг 4</b>. Сервер имен TLD отвечает ссылкой на авторитетный сервер имен зоны cloudflare — <b>шаг 5</b>.\"},{\"type\":\"subsubtitle\",\"content\":\"Авторитетный DNS-сервер имен\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Авторитетный сервер имен DNS</b>. Этот окончательный сервер имен можно рассматривать как словарь на полке с книгами, в котором конкретное имя может быть переведено в его определение. Полномочный сервер имен является последней остановкой в запросе сервера имен. Если полномочный сервер имен имеет доступ к запрошенной записи, он вернет IP-адрес для запрошенного имени хоста обратно рекурсору DNS, который сделал первоначальный запрос.\"]},{\"type\":\"paragraph\",\"content\":\"DNS-сервер рекурсивного кэширования отправляет повторяющийся запрос на сервер <b>\\\"cloudflare\\\"</b> для <b>\\\"cloudflare.com\\\"</b> — <b>шаг 6</b>. Авторитетный сервер имен <b>\\\"cloudflare.com\\\"</b> возвращает IP-адрес для <b>\\\"cloudflare.com\\\"</b> — <b>шаг 7</b>. DNS-сервер с рекурсивным кэшированием отвечает исходному клиенту IP-адресом <b>\\\"cloudflare.com\\\"</b> — <b>шаг 8</b> — и клиент взаимодействует с веб-сервером <b>\\\"cloudflare.com\\\"</b> — <b>шаги 9 и 10</b>.\"},{\"type\":\"paragraph\",\"content\":\"Отлично, вот и все о поиске DNS. Теперь вы знаете, как это работает и какие компоненты задействованы. Вероятно, вы заметили, что существует множество \\\"DNS-серверов\\\". Когда я говорю \\\"DNS-сервер\\\", я буквально имею в виду всю эту инфраструктуру, потому что DNS-сервер просто объединяет внутри все роли.\"},{\"type\":\"subsubtitle\",\"content\":\"DNS Root Nameserver vs DNS Root Server\"},{\"type\":\"paragraph\",\"content\":\"Помните рисунок под названием <b>Полный поиск DNS и запрос веб-страницы</b>. На этой картинке есть одна огромная ошибка. Видите ли, шаги 2 и 3 говорят о связи с <b>корневым DNS-сервером</b>, но на самом деле это <b>корневой DNS-сервер имен</b>. Чрезвычайно важно их различать. Итак, позвольте мне объяснить разницу:\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Корневые серверы DNS</b> — это 13 полномочных серверов имен, отвечающих за ответы на запросы в корневой зоне системы доменных имен (DNS). Эти серверы эксплуатируются различными организациями по всему миру и обозначаются буквами от A до M. Они являются первым шагом в процессе преобразования доменного имени в IP-адрес и помогают направлять трафик в соответствующий домен верхнего уровня (TLD) сервер имен.\",\"<b>Корневые серверы имен DNS</b> — набор серверов имен, обслуживающих корневую зону DNS. Эти серверы имен отвечают за предоставление ссылок на серверы имен ДВУ и другие авторитетные серверы имен и играют важнейшую роль в функционировании DNS. Термин \\\"корневой сервер имен\\\" часто используется взаимозаменяемо с термином \\\"корневой сервер\\\", но, строго говоря, первый относится конкретно к серверам имен, которые обслуживают корневую зону.\"]},{\"type\":\"subtitle\",\"content\":\"Типы DNS рекордов\"},{\"type\":\"paragraph\",\"content\":\"В начале нашего пути я сказал, что до какого-то момента мы должны рассматривать DNS как нечто, преобразующее URL-адреса в IP-адреса веб-сайтов. Технически это верно, но только отчасти. DNS отвечает за преобразование <b>каждого удобочитаемого имени ресурса в IP-адрес</b>. Сюда входят не только веб-сайты (IPv4 и IPv6), но и, например, почтовые серверы. Они называются <b>типами записей DNS</b>. Кратко остановимся на наиболее важных из них.\"},{\"type\":\"subsubtitle\",\"content\":\"A Рекорд (address)\"},{\"type\":\"list-bullet\",\"items\":[\"<b>A Рекорд (address)</b> — показывает IP-адрес для определенного имени хоста или домена. Работает только для типа IPv4. В основном используется для поиска IP-адреса. Используя запись A, веб-браузер может загрузить веб-сайт с использованием доменного имени.\"]},{\"type\":\"subsubtitle\",\"content\":\"AAAA Рекорд (quad A)\"},{\"type\":\"list-bullet\",\"items\":[\"<b>AAAA Рекорд (quad A)</b> — точно так же, как рекорд А указывает на IP-адрес для домена, вместо использования IPv4 используется IPv6. Основное использование if такое же, как и для типа A, но доменное имя преобразуется в более новый адрес протокола IPv6. Мобильные телефоны предпочитают IPv6, если он доступен.\"]},{\"type\":\"subsubtitle\",\"content\":\"MX Рекорд (Mail eXchange)\"},{\"type\":\"list-bullet\",\"items\":[\"<b>MX Рекорд (Mail eXchange)</b> — позволяет направлять электронные письма на почтовый сервер, показывая, куда должны направляться электронные письма для домена. У вас может быть несколько записей MX для одного доменного имени — по сути, просто резервные серверы электронной почты. Чем ниже значение приоритета для сервера, тем он важнее. А в случае, если первичный сервер выйдет из строя, будет использоваться вторичный сервер - схема актив-актив.\"]},{\"type\":\"paragraph\",\"content\":\"Основное его использование — указать, куда должна быть доставлена электронная почта. Должен указывать на имя почтового сервера, а не на IP-адрес. <b>ANAME</b> — может указывать на имя почтового сервера или IP-адрес.\"},{\"type\":\"subsubtitle\",\"content\":\"NS Рекорд (nameserver)\"},{\"type\":\"list-bullet\",\"items\":[\"<b>NS Рекорд (nameserver)</b> — указывает полномочный DNS-сервер для домена. Другими словами, запись NS помогает указать, где интернет-приложение, такое как веб-браузер, может найти IP-адрес для доменного имени. Обычно для домена указывается несколько серверов имен. Основное использование этих авторитетных серверов заключается в подключении вашего доменного имени к фактическому серверу, на котором размещен ваш сайт. Серверы имен содержат другие записи DNS, такие как записи MX или A.\"]},{\"type\":\"subsubtitle\",\"content\":\"CNAME Рекорд (Canonical Name)\"},{\"type\":\"list-bullet\",\"items\":[\"<b>CNAME Рекорд (Canonical Name)</b> — это запись DNS, которая указывает доменное имя (псевдоним) на другой домен. В записи CNAME псевдоним не указывает на IP-адрес. И доменное имя, на которое указывает псевдоним, является каноническим именем.\"]},{\"type\":\"paragraph\",\"content\":\"Например, поддомен ng.example.com (ng.example.com — запись CNAME) может указывать на example.com с помощью CNAME. Здесь example.com указывает на фактический IP-адрес, используя запись A.\"},{\"type\":\"paragraph\",\"content\":\"Основное его использование — запуск нескольких поддоменов для разных целей на одном сервере. Например, у нас есть ftp.example.com и www.example.com. Затем мы можем использовать запись CNAME, чтобы указать оба субдомена на example.com. Затем основной домен example.com указывает на IP-адрес сервера с помощью записи A. Также возможно, что один CNAME указывает на другой CNAME. Однако это неэффективно и может привести к снижению скорости загрузки и плохому взаимодействию с пользователем.\"},{\"type\":\"paragraph\",\"content\":\"Usually points to a load balancer.\"},{\"type\":\"subsubtitle\",\"content\":\"ANAME Рекорд\"},{\"type\":\"list-bullet\",\"items\":[\"<b>ANAME (ALIAS)</b> — комбинация записей CNAME и A. ANAME — это не DNS-запись, а способ ее имитации. И именно поэтому он называется Псевдоним. Как и CNAME, ANAME сопоставляет одно доменное имя с другим. Итак, ANAME настроено так, чтобы указывать на другой домен. Когда доменное имя, на которое указывает ANAME, запрашивается клиентским браузером, он отвечает IP-адресом. С другой стороны, CNAME не может указывать на IP-адрес, а ANAME может.\"]},{\"type\":\"paragraph\",\"content\":\"Был использован в прошлом, CNAME в настоящее время является королем. Не следует указывать на балансировщик нагрузки.\"},{\"type\":\"subsubtitle\",\"content\":\"TXT Рекорд\"},{\"type\":\"list-bullet\",\"items\":[\"<b>TXT Рекорд (Text Record)</b> — это тип записи, который позволяет администратору добавлять удобочитаемые (и машиночитаемые) заметки в DNS. Не требует определенного формата. Используется для предоставления возможности связать произвольный текст с хостом или другим именем, например, удобочитаемую информацию о сервере, сети, центре обработки данных или другую учетную информацию.\"]},{\"type\":\"paragraph\",\"content\":\"В настоящее время он используется в основном для предотвращения спама по электронной почте и подтверждения права собственности на домен. Здесь мы должны поговорить о DMARC, SPF и DKIM, а пока просто знайте, что речь идет о <b>защите от спама</b>.\"},{\"type\":\"title\",\"content\":\"Проблемы безопасности DNS\"},{\"type\":\"paragraph\",\"content\":\"Хорошо, теперь у нас есть полный обзор того, как работает разрешение DNS, каковы разные роли DNS-серверов и даже упомянута пара основных типов записей, но как насчет вопросов безопасности? На самом деле у нас есть только 2 основные проблемы безопасности — <b>отсутствие аутентификации и конфиденциальность</b>.\"},{\"type\":\"paragraph\",\"content\":\"Первая связана с тем, что DNS не может проверить, поступила ли запрошенная запись из надежного источника, и эта проблема устраняется с помощью <b>DNSSEC</b>.\"},{\"type\":\"paragraph\",\"content\":\"Во-вторых, это связано с тем, что DNS как протокол был реализован в начале 80-х годов. Как вы уже знаете, в то время безопасность не стояла на первом плане, а все ресурсы были сосредоточены на обеспечении просто доступности. Поэтому DNS, как и многие другие протоколы, такие как HTTP или ART, передает данные в виде открытого текста. Эта проблема устраняется с помощью <b>шифрования</b>.\"},{\"type\":\"paragraph\",\"content\":\"Хорошо, мы обязательно обсудим оба вопроса, но давайте сначала посмотрим, как выглядит DNS после взлома:\"},{\"type\":\"list-numeric\",\"items\":[\"Клиент отправляет рекурсивный запрос на свой локальный DNS-сервер рекурсивного кэширования для получения IP-адреса веб-страницы <b>\\\"cloudflare.com\\\"</b>.\",\"DNS-сервер с рекурсивным кэшированием отправляет итеративный запрос корневому (<b>\\\".\\\"</b>) серверу имен IP-адреса веб-страницы <b>\\\"cloudflare.com\\\"</b>.\",\"Корневой сервер имен отвечает ссылкой на сервер имен TLD зоны <b>\\\".com\\\"</b>.\",\"DNS-сервер с рекурсивным кэшированием отправляет повторяющийся запрос на сервер доменных имен <b>\\\".com\\\"</b> для получения IP-адреса веб-страницы <b>\\\"cloudflare.com\\\"</b>.\",\"Сервер доменных имен <b>.com\\\"</b> отвечает ссылкой на авторитетный сервер имен зоны <b>\\\"cloudflare\\\"</b>.\",\"DNS-сервер с рекурсивным кэшированием отправляет итеративный запрос полномочному серверу имен <b>\\\"cloudflare\\\"</b> для получения IP-адреса веб-страницы <b>\\\"cloudflare.com\\\"</b>.\",\"Злонамеренный DNS-сервер отвечает вредоносным IP-адресом <b>\\\"cloudflare.com\\\"</b>.\",\"DNS-сервер с рекурсивным кэшированием отвечает исходному клиенту вредоносным IP-адресом <b>\\\"cloudflare.com\\\"</b>.\",\"Клиент взаимодействует с вредоносным веб-сервером, который либо отвечает напрямую, либо выполняет операцию атаки <b>Человек посередине</b>, пропуская и наблюдая (или изменяя) трафик с/на законный веб-сервер.\"]},{\"type\":\"picture\",\"width\":\"w70\",\"resource\":\"dns_poisoning.jpeg\"},{\"type\":\"paragraph\",\"content\":\"Как видите, с шага 1 по шаг 6 у нас точно такой же поток, проблемы начинаются с шага 7.\"},{\"type\":\"paragraph\",\"content\":\"Это называется <b>спуфинг DNS/отравление кэша</b> — это атака, при которой поддельные данные DNS вводятся в кэш преобразователя DNS, в результате чего преобразователь возвращает неверный IP-адрес для домена. Вместо перехода на правильный веб-сайт трафик может быть перенаправлен на вредоносную машину или куда-либо еще по желанию злоумышленника; часто это будет копия исходного сайта, используемая в злонамеренных целях, таких как распространение вредоносных программ или сбор данных для входа.\"},{\"type\":\"paragraph\",\"content\":\"Итак, нам нужно как-то убедиться, что ответ исходит из надежного источника, верно? По сути, предоставить <b>аутентификацию</b> — здесь в игру вступает <b>DNSSEC</b>.\"},{\"type\":\"title\",\"content\":\"Обзор DNSSEC\"},{\"type\":\"paragraph\",\"content\":\"Наконец-то мы здесь, DNSSEC! Мы должны учитывать, что DNS и DNSSEC сейчас такие же, как HTTP и HTTPS 20 лет назад. Его просто необходимо будет использовать всем, чтобы обеспечить безопасную связь. DNSSEC и HTTPS в некоторых случаях даже похожи.\"},{\"type\":\"paragraph\",\"content\":\"HTTPS обеспечивает как <b>аутентификацию</b>, так и <b>конфиденциальность</b>, используя инфраструктуру PKI ЦС (если вы не знакомы - <a href='https://blog.mikhailbahdashych.me/en/blog /pki-infrastructure-or-how-to-build-your-own-vpn' class='inline-link en'>см. здесь</a>). <b>Аутентификация</b> обеспечивается путем проверки того, кто выдал сертификат, а <b>конфиденциальность</b> обеспечивается за счет шифрования трафика.\"},{\"type\":\"paragraph\",\"content\":\"В случае DNSSEC он обеспечивает только <b>аутентификацию</b>, тогда как шифрование DNS обеспечивает <b>конфиденциальность</b>, о чем уже говорилось выше. Но возвращаясь к DNSSEC, давайте начнем с простого определения того, что это такое на самом деле:\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNSSEC</b> — это механизм аутентификации, использующий криптографию PKI для предотвращения спуфинга. С DNSSEC криптографически подписаны не сами DNS-запросы и ответы, а сами данные DNS, подписанные владельцем данных.\"]},{\"type\":\"paragraph\",\"content\":\"Помните, мы упоминали, что DNS имеет иерархическую структуру? На примере DNSSEC это станет еще более очевидным. Предполагая, что вы уже знакомы с PKI и криптографией, нам нужно ввести несколько новых терминов специально для DNSSEC.\"},{\"type\":\"subtitle\",\"content\":\"Терминология DNSSEC\"},{\"type\":\"list-bullet\",\"items\":[\"<b>RRSet — набор записей ресурсов</b>. Первым шагом к обеспечению безопасности зоны с помощью DNSSEC является объединение всех записей одного типа в набор записей ресурсов (RRset). Например, если у вас есть три записи AAAA в вашей зоне на одной метке (например, label.example.com), все они будут объединены в один набор AAAA RRset.\\n\\nНа самом деле это полный набор RRset, который получает цифровую подпись, в отличие от отдельных записей DNS. Конечно, это также означает, что вы должны запрашивать и проверять все записи AAAA из зоны с одной и той же меткой, а не проверять только одну из них. Вкратце — <b>набор записей одного типа и одного домена/зоны</b>.\"]},{\"type\":\"picture\",\"width\":\"w80\",\"resource\":\"diagram-rrsets.svg\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNSKEY</b> — содержит открытый ключ подписи.\",\"<b>RRSig — подпись записи ресурса</b> — запись, содержащая цифровую подпись RRSet.\",\"<b>ZSK – ключ подписи зоны</b> – <b>используется для подписи или проверки неключевых записей домена/зоны (A, AAAA, MX и т.д.)</b>. В DNSSEC каждая зона имеет пару ключей подписи зоны (ZSK), где закрытый ключ подписывает каждый набор RRset в зоне, а открытый ключ проверяет подпись. Для реализации DNSSEC оператор зоны использует закрытый ZSK для создания цифровых подписей для каждого набора RRset и сохраняет их в виде записей RRSig на своем сервере имен.\\n\\nОднако только записи RRSig не могут использоваться преобразователями DNS для проверки подписей. Для этого оператор зоны добавляет общедоступный ZSK к своему серверу имен в записи DNSKEY.\\n\\nКогда преобразователь DNSSEC запрашивает тип записи, сервер имен возвращает соответствующий RRSig вместе с RRset. Затем преобразователь может получить общедоступный ZSK из записи DNSKEY на сервере имен. RRset, RRSig и общедоступный ZSK вместе могут проверить ответ.\\n\\nДоверие к ключу подписи зоны в записи DNSKEY также означает доверие ко всем записям в зоне. Но если ZSK скомпрометирован, крайне важно проверить общедоступный ZSK для обеспечения безопасности.\"]},{\"type\":\"picture\",\"width\":\"w60\",\"resource\":\"diagram-zone-signing-keys-2.svg\"},{\"type\":\"list-bullet\",\"items\":[\"<b>KSK – ключ для подписи ключей</b> – <b>используется для подписи или проверки ключей домена/зоны</b>. В дополнение к ключу подписи зоны серверы имен DNSSEC используют ключ подписи ключа (KSK). Подобно тому, как ZSK обеспечивал безопасность наборов RRset в предыдущем разделе, ключ KSK проверяет запись DNSKEY, подписывая общедоступный ZSK, тем самым создавая RRSIG для DNSKEY.\\n\\nОбщедоступный KSK также публикуется сервером имен в записи DNSKEY, как и общедоступный ZSK, что приводит к DNSKEY RRSet. И общедоступный KSK, и общедоступный ZSK подписываются привытным KSK. Это позволяет распознавателям использовать общедоступный KSK для проверки общедоступного ZSK.\"]},{\"type\":\"paragraph\",\"content\":\"Валидация для резолвера теперь выглядит так:\"},{\"type\":\"list-numeric\",\"items\":[\"Запросить нужный <b>RRSet</b>, который также возвращает соответствующую запись <b>RRSIG</b>.\",\"Запросить записи DNSKEY, содержащие <b>общедоступные ZSK и KSK</b>, которые также возвращают <b>RRSig</b> для <b>DNSKEY RRSet</b>.\",\"Проверить <b>RRSig</b> запрошенного <b>RRSet</b> с помощью <b>общедоступного ZSK</b>.\",\"Проверить <b>RRSig</b> в <b>DNSKEY RRSet</b> с помощью <b>общедоступного KSK</b>.\"]},{\"type\":\"picture\",\"width\":\"w60\",\"resource\":\"diagram-key-signing-keys-2.svg\"},{\"type\":\"paragraph\",\"content\":\"Вы, наверное, уже заметили иерархическую природу DNS, и это только начало. Что касается KSK, DNSKEY RRSet и соответствующие записи RRSig можно кэшировать, чтобы избежать чрезмерных запросов к серверам имен DNS.\"},{\"type\":\"paragraph\",\"content\":\"Использование отдельных ключей подписи зоны и ключей подписи ключей направлено на облегчение замены старого или скомпрометированного KSK, как мы обсудим в следующем разделе. И наоборот, изменение ZSK — это более простой процесс, позволяющий использовать ZSK меньшего размера без ущерба для безопасности сервера и уменьшения объема данных, которые сервер должен передавать с каждым ответом.\"},{\"type\":\"paragraph\",\"content\":\"Хотя мы установили доверительные отношения в нашей зоне, DNS — это иерархическая система, и зоны обычно работают в сочетании друг с другом. Ключ подписи ключа подписывается сам по себе, что не добавляет дополнительного доверия, поэтому нам нужно средство для соединения доверия в нашей зоне с его родительской зоной.\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Запись DS — делегирование подписи</b> — <b>запись, содержащая хеш/дайджест общедоступного KSK дочернего домена/зоны (отпечаток общедоступного KSK дочернего)</b>. В DNSSEC введена запись лица, подписывающего делегирование (DS), для передачи доверия из родительской зоны в дочернюю зону. Для этого оператор зоны хеширует общедоступный KSK, содержащийся в записи DNSKEY, и предоставляет его родительской зоне для публикации в виде записи DS.\\n\\nВсякий раз, когда преобразователь направляется в дочернюю зону, родительская зона также предоставляет запись DS. Эта запись позволяет преобразователям определить, включена ли в дочерней зоне DNSSEC. Чтобы проверить общедоступный KSK зоны, преобразователь хеширует его и сравнивает с записью DS из родительской зоны. Если хэш-значения совпадают, распознаватель может с уверенностью предположить, что общедоступный KSK не был скомпрометирован или изменен, тем самым устанавливая доверие ко всем записям дочерней зоны. <b>Вот как в DNSSEC устанавливается цепочка доверия.</b>\"]},{\"type\":\"picture\",\"width\":\"w50\",\"resource\":\"diagram-delegation-signer-records.svg\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Цепочка доверия</b> — процесс установления доверия внутри зоны и привязки ее к родительской зоне требует наличия механизма проверки подлинности записи DS. Это достигается цифровой подписью записи DS, аналогично любому другому набору RRSet, в результате чего в родительской зоне существует соответствующий RRSig. Процесс проверки этой подписи повторяется последовательно, вплоть до общедоступного ключа KSK родительской зоны. Чтобы подтвердить подлинность этого KSK, необходимо проверить родительскую запись DS, продолжая этот процесс вверх по цепочке доверия.\"]},{\"type\":\"picture\",\"width\":\"w50\",\"resource\":\"diagram-the-chain-of-trust.svg\"},{\"type\":\"subtitle\",\"content\":\"Разрешения DNSSEC адресов\"},{\"type\":\"paragraph\",\"content\":\"О, это было тяжело, не так ли? Ладно, хватит этой терминологии, все лучше видно на примерах. Мы собираемся изменить наш предыдущий поток разрешения DNS, чтобы включить DNSSEC.\"},{\"type\":\"list-numeric\",\"items\":[\"Клиент отправляет рекурсивный запрос на свой локальный DNS-сервер рекурсивного кэширования для получения IP-адреса веб-страницы <b>\\\"cloudflare.com\\\"</b>.\",\"DNS-сервер с рекурсивным кэшированием отправляет итеративный запрос корневому (<b>\\\".\\\"</b>) серверу имен IP-адреса веб-страницы <b>\\\"cloudflare.com\\\"</b>.\",\"Корневой сервер имен:\",[\"Отправляет реферал:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"Незащищенная ссылка на авторитетный сервер имен TLD для зоны <b>\\\".com\\\"</b>.\"]},\"Отправляет запись:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>RRSet записей DNSKEY</b> для корневой зоны — <b>общедоступный ZSK и общедоступный KSK</b> корневой зоны.\",\"<b>RRSig</b> вышеуказанного набора записей, подписанный с использованием <b>приватного ключа KSK</b> корневой зоны.\",\"<b>Запись DS</b> для зоны <b>\\\".com\\\"</b> — хэш/дайджест/отпечаток общедоступного ключа KSK зоны \\\".com\\\".\",\"<b>RRSig</b> вышеуказанной записи DS — подписано с использованием приватного ZSK корневой зоны.\"]}],\"Рекурсивный кэширующий DNS-сервер:\",[\"Проверяет запись:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>Набор RRSet DNSKEY</b> <b>корневой зоны</b> подтверждается успешной расшифровкой RRSig набора RRSet с использованием общедоступного ключа KSK корневой зоны.\",\"Запись DS <b>корневой</b> зоны для зоны <b>\\\".com\\\"</b> подтверждается успешной расшифровкой RRSig записи с использованием общедоступного ZSK <b>корневой</b> зоны.\"]},\"Проверяет зону:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"DNS-сервер с рекурсивным кэшированием уже имеет доверенную копию общедоступного корневого KSK, которую он получил с помощью средств, отличных от протокола DNS (например, от поставщика операционной системы сервера). Корневая зона проверяется DNS-сервером с рекурсивным кэшированием, когда обнаруживается, что серверная копия общедоступного корневого ключа KSK совпадает с копией, предоставленной серверу корневым DNS-сервером.\"]}],\"DNS-сервер с рекурсивным кэшированием отправляет итеративный запрос серверу имен домена верхнего уровня <b>\\\".com\\\"</b> для <b>\\\"cloudflare.com\\\"</b>.\",\"Сервер имен TLD <b>\\\".com\\\"</b>:\",[\"Отправляет реферал:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"Незащищенный реферал для авторитетного сервера имен зоны <b>\\\"cloudflare\\\"</b>.\"]},\"Отправляет записи:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>RRSet записей DNSKEY</b> для зоны \\\".com\\\" - <b>общедоступный ZSK и общедоступный KSK</b> зоны \\\".com\\\".\",\"<b>RRSig</b> вышеуказанного набора записей, подписанный с использованием <b>приватного ключа KSK</b> \\\".com\\\".\",\"<b>Запись DS</b> для зоны <b>\\\"cloudflare\\\"</b> — хэш/дайджест/отпечаток общедоступного ключа KSK зоны \\\"cloudflare\\\".\",\"<b>RRSig</b> вышеприведенной записи DS - подписано с использованием частного ZSK зоны \\\".com\\\".\"]}],\"Рекурсивный кэширующий DNS-сервер:\",[\"Проверяет записи:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>\\\".com\\\" DNSKEY RRSet<b/b> подтверждается успешной расшифровкой RRSig RRSet с использованием общедоступного KSK зоны \\\".com\\\".\",\"Запись DS зоны <b>\\\".com\\\"</b> для зоны <b>\\\"cloudflare\\\"</b> подтверждается успешной расшифровкой RRSig записи с использованием общедоступного ZSK зоны <b>\\\".com\\\"</b>.\"]},\"Проверяет зону:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"Зона <b>\\\".com\\\"</b> проверяется путем сравнения хэша/дайджеста/отпечатка пальца общедоступного KSK зоны <b>\\\".com\\\"</b> с <b>\\\".com\\\"</ b> с ранее полученной DS-записью из корневой зоны для зоны <b>\\\".com\\\"</b>.\"]}],\"DNS-сервер с рекурсивным кэшированием отправляет повторяющийся запрос авторитетному серверу имен \\\"cloudflare\\\" для \\\"cloudflare.com\\\".\",\"Авторитетный сервер имен \\\"cloudflare\\\":\",[\"Отправляет записи:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>RRSet записей DNSKEY</b> для зоны <b>\\\"cloudflare\\\"</b> — общедоступный ключ ZSK и ключ KSK зоны <b>\\\"cloudflare\\\"</b>.\",\"<b>RRSig</b> вышеуказанного набора записей, подписанный с использованием закрытого ключа <b>\\\"cloudflare\\\"</b>.\",\"<b>RRSet из A записей</b> из зоны <b>\\\"cloudflare\\\"</b>.\",\"<b>RRSig</b> вышеуказанной записи DS — подписано с использованием частного ZSK зоны <b>\\\"cloudflare\\\"</b>.\"]}],\"Рекурсивный кэширующий DNS-сервер:\",[\"Проверяет записи:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>\\\"cloudflare\\\" DNSKEY RRSet</b> подтверждается успешной расшифровкой RRSig RRSet с использованием общедоступного KSK зоны <b>\\\"cloudflare\\\"</b>.\",\"<b>\\\"cloudflare\\\" RRSet</b> подтверждается успешной расшифровкой RRSig RRSet с использованием общедоступного ZSK зоны <b>\\\"cloudflare\\\"</b>.\"]},\"Проверяет зону:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"Зона <b>\\\"cloudflare\\\"</b> проверяется путем сравнения хэша/дайджеста/отпечатка пальца общедоступного KSK зоны <b>\\\"cloudflare\\\"</b> с зоной <b>\\\"cloudflare\\\"</b> с ранее полученной записью DS из корневой зоны для зоны <b>\\\"cloudflare\\\"</b>.\"]}],\"DNS-сервер рекурсивного кэширования отвечает исходному клиенту с IP-адресом <b>\\\"cloudflare.com\\\"</b>.\",\"Клиент взаимодействует с веб-сервером <b>\\\"cloudflare.com\\\"</b>.\"]},{\"type\":\"paragraph\",\"content\":\"Есть одна вещь, которую вам нужно понять. Все те примеры, которые представлены здесь о том, как работает DNS, являются академическими примерами. Это происходит только в стерильных, \\\"лабораторных\\\" условиях (в данном случае, если нигде не было схрона). Эти понятия достаточно легко понять, что они имеют место быть, в реальности же если и приходится настраивать такую систему, то это буквально несколько строк кода или изменение конфигурации.\"},{\"type\":\"paragraph\",\"content\":\"Такие примеры скорее понадобятся людям, проектирующим сети и инфраструктуры такого масштаба.\"},{\"type\":\"paragraph\",\"content\":\"Говоря о самом примере DNS, разные конфигурации представляют разные функции. Как упоминалось выше, все эти рекурсивные распознаватели, кеширующий сервер или корневые серверы имен — это просто роли, физически это может быть одна машина. Следовательно, конфигурация вашего DNS-сервера также зависит от того, что вы хотите построить. Поэтому будьте осторожны с рекомендациями, которые вы найдете в Интернете.\"},{\"type\":\"title\",\"content\":\"Церемония подписания корневого каталога DNSSEC\"},{\"type\":\"paragraph\",\"content\":\"О, на самом деле, чтобы понять, как все устроено, вам не нужно ничего знать об этой церемонии, но она выглядит так круто и звучит так пафосно, что я не мог не написать об этом. <b>Ключи к Интернету</b>, неплохо, да?\"},{\"type\":\"paragraph\",\"content\":\"Вы, наверное, уже обратили внимание на то, как эта иерархия DNS идет снизу вверх. В таком случае у вас может возникнуть логичный вопрос: что находится на самом верху?\"},{\"type\":\"paragraph\",\"content\":\"В этом заключается цель церемонии подписания корневого каталога — строгой процедуры подписания информации об открытых ключах корневой зоны DNS на следующие несколько месяцев. Закрытый ключ подписи, используемый в этом процессе, буквально является ключом ко всему Интернету, защищенному с помощью DNSSEC. Публичная, проверенная и строго контролируемая церемония доступа к этому ключу необходима для того, чтобы DNSSEC преуспела в качестве глобального стандарта.\"},{\"type\":\"paragraph\",\"content\":\"Просто найдите видео этой церемонии, потому что оно переведено в Интернете, и посмотрите, откуда берется доверие к DNSSEC.\"},{\"type\":\"title\",\"content\":\"О шифровании DNS\"},{\"type\":\"paragraph\",\"content\":\"Как вы уже выяснили, DNSSEC обеспечивает только аутентификацию, но все равно передает ее в открытом виде. Вот где в игру вступает криптография, наши любимые HTTPS и TLS, которые помогут нам обеспечить не только аутентификацию нашего трафика, но и его конфиденциальность.\"},{\"type\":\"subtitle\",\"content\":\"DNS через TLS\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS через TLS (или DoT)</b> — это стандарт шифрования DNS-запросов, обеспечивающий их безопасность и конфиденциальность. DoT использует тот же протокол, что и HTTPS, для шифрования и аутентификации соединения. Обычно DNS работает через UDP. Что делает DoT, так это добавляет шифрование TLS поверх протокола пользовательских дейтаграмм (UDP), который используется для DNS-запросов. Кроме того, это гарантирует, что DNS-запросы и ответы не будут подделаны или подделаны с помощью атак на пути.\"]},{\"type\":\"subtitle\",\"content\":\"DNS через HTTPS\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS через HTTPS (или DoH)</b> — это альтернатива DoT. DNS-запросы и ответы шифруются, но отправляются через протоколы HTTP или HTTP/2, а не напрямую через UDP. Трафик DoH выглядит как другой трафик HTTPS — например. обычное взаимодействие пользователя с веб-сайтами и веб-приложениями — с точки зрения сетевого администратора.\"]},{\"type\":\"paragraph\",\"content\":\"В феврале 2020 года браузер Mozilla Firefox начал по умолчанию включать DoH для пользователей из США. DNS-запросы из браузера Firefox шифруются DoH и отправляются либо в Cloudflare, либо в NextDNS. Некоторые другие браузеры также поддерживают DoH, хотя по умолчанию он не включен.\"},{\"type\":\"subtitle\",\"content\":\"Разница между DoT и DoH\"},{\"type\":\"paragraph\",\"content\":\"Основное различие между ними заключается в том, <b>какой порт они используют</b>. DoT использует только порт 853, в то время как DoH использует порт 443, который также используется для всего остального HTTPS-трафика.\"},{\"type\":\"paragraph\",\"content\":\"Поскольку у DoT есть выделенный порт, любой, у кого есть доступ к сети, может видеть входящий и исходящий трафик DoT, даже если сами запросы и ответы зашифрованы. Напротив, при DoH DNS-запросы и ответы маскируются внутри другого HTTPS-трафика, поскольку все они приходят и уходят с одного и того же порта.\"},{\"type\":\"paragraph\",\"content\":\"<b>С точки зрения сетевой безопасности DoT, возможно, лучше</b>. Это дает сетевому администратору возможность отслеживать и блокировать DNS-запросы, что важно для выявления и пресечения вредоносной активности.\"},{\"type\":\"paragraph\",\"content\":\"<b>Запросы DoH, тем временем, скрыты в обычном HTTPS-трафике</b>, а это означает, что их нельзя легко заблокировать без блокировки всего остального HTTPS-трафика. Однако с точки зрения конфиденциальности DoH, возможно, предпочтительнее. С DoH DNS-запросы скрыты в более крупном потоке HTTPS-трафика. Это дает сетевым администраторам меньшую видимость, но предоставляет пользователям большую конфиденциальность.\"},{\"type\":\"title\",\"content\":\"Выводы\"},{\"type\":\"paragraph\",\"content\":\"В заключение, DNS (система доменных имен) является фундаментальным компонентом Интернета, который используется для преобразования доменных имен в IP-адреса. Хотя DNS имеет решающее значение для подключения к Интернету и онлайн-сервисов, он также уязвим для целого ряда атак на основе DNS, включая отравление кеша и спуфинг DNS.\"},{\"type\":\"paragraph\",\"content\":\"Для решения этих проблем безопасности был разработан DNSSEC (расширения безопасности системы доменных имен) в качестве протокола безопасности, который добавляет уровень криптографической защиты в систему DNS. Используя цифровые подписи для проверки подлинности ответов DNS, DNSSEC помогает защититься от целого ряда атак, связанных с DNS, обеспечивая целостность и надежность системы DNS.\"},{\"type\":\"paragraph\",\"content\":\"Хотя внедрение DNSSEC идет медленно, оно становится все более важным, поскольку угроза атак на основе DNS продолжает расти. Организациям, использующим онлайн-сервисы, следует рассмотреть возможность внедрения DNSSEC для защиты своего присутствия в Интернете, повышения безопасности своей сети и снижения риска атак на основе DNS. Поскольку Интернет продолжает развиваться, DNS и DNSSEC останутся важными компонентами глобальной сети, гарантируя надежность и безопасность онлайн-сервисов на долгие годы.\"},{\"type\":\"title\",\"content\":\"Контакты и рекомендации\"}]",
          references: "[{\"name\":\"Что такое DNS от Cloudflare\",\"link\":\"https://www.cloudflare.com/en-gb/learning/dns/what-is-dns/\"},{\"name\":\"Что такое DNSSEC от Cloudflare (очевидно, не так ли?)\",\"link\":\"https://www.cloudflare.com/en-gb/dns/dnssec/how-dnssec-works/\"},{\"name\":\"DNS через TLS vs DNS через HTTPS\",\"link\":\"https://www.cloudflare.com/en-gb/learning/dns/dns-over-tls/\"},{\"name\":\"Отравление кэша DNS и спуфинг\",\"link\":\"https://www.cloudflare.com/en-gb/learning/dns/dns-cache-poisoning/\"},{\"name\":\"Люди, которые держат ключи от Интернета\",\"link\":\"https://www.cloudflare.com/en-gb/dns/dnssec/root-signing-ceremony/\"},{\"name\":\"Хорошо написанная статья ICANN о том, что такое DNSSEC и почему это важно\",\"link\":\"https://www.icann.org/resources/pages/dnssec-what-is-it-why-important-2019-03-05-en\"},{\"name\":\"Действительно классное видео, объясняющее DNS и DNSSEC.\",\"link\":\"https://www.youtube.com/watch?v=_8M_vuFcdZU\"}]",
          created_at: new Date(),
          updated_at: new Date()
        },
        {
          id: uuid.v4(),
          language: 'pl',
          title: 'Jak działa DNS i dlaczego potrzebujemy DNSSEC',
          slug: 'how-does-dns-work-and-why-we-need-dnssec',
          tags: 'mikhail,bahdashych,mikhail bahdashych,blog,dns,dnssec',
          type: ['theory'],
          description: 'Słyszałeś kiedyś o DNS? Założę się, że tak! Założę się również, że jeśli próbowałeś dowiedzieć się, o co w tym wszystkim chodzi, widziałeś DNSSEC. Cóż... czas dowiedzieć się, jak głęboka jest ta królicza nora...',
          page_description: 'Chyba wszyscy słyszeliście o DNS. To jest internetowa książka telefoniczna, która konwertuje czytelne dla człowieka nazwy domen na adresy IP przetwarzane przez maszyny i bla-bla-bla. Szczerze mówiąc, to dosłownie królicza nora i postanowiłem dowiedzieć się, jak głęboka jest. Cóż, zaufaj mi, będziesz zaskoczony, a ja mam cholernie ciekawe rzeczy do podzielenia się z tobą. Więc zanurzmy się w to!',
          search_tags: ['dns', 'dnssec'],
          intro: 'Królicza dziura — to chyba najlepszy opis DNS, jaki znalazłem. Byłem wystarczająco naiwny, by sądzić, że jedyne, co robi, to konwertowanie nazw domen na adresy IP, aby zapewnić, że nazwy czytelne dla człowieka są zrozumiałe dla maszyn. Nie mam pojęcia, jak bardzo się myliłem, myśląc w ten sposób.',
          footer: 'Phew... To było trochę skomplikowane, prawda? Ale teraz wiesz, czym właściwie są DNS i DNSSEC i jak działają. Jeśli po przeczytaniu masz jeszcze więcej pytań niż wcześniej, gratuluję, od teraz będziesz mógł sam znaleźć wszystkie odpowiedzi, ale na razie to wszystko. Dziękuję bardzo za przeczytanie.',
          toc: "{\"intro\":\"Wstęp\",\"Przegląd DNS\":{\"terminology\":\"Terminologia DNS\",\"resolutionFlow\":\"Przepływ rozpoznawania DNS\",\"Role serwerów DNS i pełne wyszukiwanie\":{\"stubResolver\":\"DNS Stub Resolver\",\"recursiveResolver\":\"Rekurencyjny mechanizm rozpoznawania nazw DNS\",\"rootNameserver\":\"Główny serwer nazw DNS\",\"tldNameserver\":\"Serwer nazw DNS TLD\",\"authNameserver\":\"Autorytatywny serwer nazw DNS\",\"rootNameserverVsRootServer\":\"DNS Root Nameserver vs DNS Root Server\"},\"Typy rekordów DNS\":{\"aRec\":\"A Rekord (address)\",\"quadA\":\"AAAA Rekord (quad A)\",\"mxRec\":\"MX Rekord (Mail eXchange)\",\"nsRec\":\"NS Rekord (nameserver)\",\"cnameRec\":\"CNAME Rekord (Canonical Name)\",\"anameRec\":\"ANAME Rekord\",\"txtRec\":\"TXT Rekord\"}},\"dnsSecIssues\":\"Problemy z bezpieczeństwem DNS\",\"Przegląd DNSSEC\":{\"terminology\":\"Terminologia DNSSEC\",\"resolutionFlow\":\"Przepływ rozpoznawania DNSSEC\"},\"dnssecSignCeremony\":\"Ceremonia podpisania roota DNSSEC\",\"O szyfrowaniu DNS\":{\"dot\":\"DNS over TLS\",\"doh\":\"DNS over HTTPS\",\"difference\":\"Różnica między DoT a DoH\"},\"conclusion\":\"Wnioski\",\"references\":\"Kontakt i referencje\"}",
          content: "[{\"type\":\"title\",\"content\":\"Wstęp\"},{\"type\":\"paragraph\",\"content\":\"W dzisiejszej erze cyfrowej system nazw domen (DNS) odgrywa istotną rolę w ułatwianiu komunikacji online i umożliwianiu użytkownikom dostępu do stron internetowych i usług w Internecie. Jednak wraz ze wzrostem liczby zagrożeń cyberbezpieczeństwa i złośliwych działań rośnie obawa o bezpieczeństwo DNS i potencjalne ryzyko z nim związane.\"},{\"type\":\"paragraph\",\"content\":\"W tym miejscu pojawia się DNS Security Extensions (DNSSEC), oferując potężne rozwiązanie wzmacniające bezpieczeństwo DNS i chroniące przed różnymi atakami, takimi jak fałszowanie DNS, zatrucie pamięci podręcznej i inne formy cyberzagrożeń.\"},{\"type\":\"paragraph\",\"content\":\"W tym poście na blogu przyjrzymy się bliżej, czym są DNS i DNSSEC, jak działają i dlaczego są niezbędne do utrzymania bezpiecznej i niezawodnej infrastruktury internetowej. Zbadamy również niektóre rzeczywiste przypadki użycia i omówimy korzyści i ograniczenia DNSSEC. Jeśli więc chcesz dowiedzieć się więcej o DNS i DNSSEC oraz o tym, jak mogą one pomóc w zabezpieczeniu twojej obecności w Internecie, czytaj dalej!\"},{\"type\":\"title\",\"content\":\"Przegląd DNS\"},{\"type\":\"paragraph\",\"content\":\"Tak samo jak zawsze zacznijmy od krótkiego opisu czym właściwie jest DNS i jak można go opisać. Najpopularniejsza definicja DNS zawsze brzmi mniej więcej tak:\"},{\"type\":\"list-bullet\",\"items\":[\"<b> DNS (Domain Name System)</b> — system, który tłumaczy czytelne dla człowieka nazwy domen na adres IP, dzięki czemu maszyny mogą komunikować się ze sobą za pomocą tych adresów IP.\"]},{\"type\":\"paragraph\",\"content\":\"Brzmi łatwo, prawda? Chciałem spróbować zagłębić się trochę głębiej, aby dowiedzieć się, co się stanie po wpisaniu adresu URL w przeglądarce i naciśnięciu przycisku Enter. Chciałem wiedzieć, co dzieje się za kulisami i jak Twój komputer uzyskuje adres IP źródłowego serwera www.\"},{\"type\":\"subtitle\",\"content\":\"Terminologia DNS\"},{\"type\":\"paragraph\",\"content\":\"Ale zanim zaczniemy, zdefiniujmy terminologię, której będziemy używać przez całą naszą długą podróż. Możesz do nich wrócić, kiedy tylko tego potrzebujesz:\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Domena DNS/Strefa DNS</b> — sekcja przestrzeni nazw DNS. Na przykład: blog.mikhailbahdashych.me. (kropka końcowa nie jest literówką) to serwer o nazwie \\\"blog\\\" w domenie/strefie\\\" mikhailbahdashych\\\", który znajduje się w domenie/strefie \\\".me\\\", która znajduje się w \\\"root (.)\\\" domenie/strefie.\",\"<b>Iteracyjne zapytanie DNS</b> — żądanie do serwera DNS: \\\"Daj mi wszelką pomoc, ale nie pytaj nikogo innego\\\".\",\"<b>Rekurencyjne zapytanie DNS</b> — żądanie do serwera DNS: \\\"Daj mi to, czego potrzebuję i zapytaj wszystkich, których chcesz\\\".\",\"<b>Serwer DNS</b> — termin opisujący całą infrastrukturę ról DNS. W porządku, jeśli w tym momencie tego nie rozumiesz, wyjaśnimy to.\",\"<b>Zapytanie DNS lub żądanie</b> — żądanie rozdzielczości nazwy domeny na adres IP.\"]},{\"type\":\"subtitle\",\"content\":\"Przepływ rozpoznawania DNS\"},{\"type\":\"paragraph\",\"content\":\"Pierwszą rzeczą, o której musimy wiedzieć, jest: w jaki sposób twoja przeglądarka wysyła tekst w postaci adresu URL i odzyskuje adres IP żądanej witryny? W tej chwili omawiamy DNS tylko z perspektywy, że jedyne, co robi, to konwersja adresów URL na adres IP stron internetowych, ale nieco później rozszerzymy jego użycie.\"},{\"type\":\"paragraph\",\"content\":\"Tutaj w grę wchodzi <b>przepływ rozdzielczości DNS</b>. Wszystko jest lepsze na przykładach, więc powiedzmy, że chcesz poprosić o <b>cloudflare.com. (kropka końcowa nie jest literówką)</b>. Przede wszystkim pozwólcie, że przedstawię wam sekwencję wszystkich żądań, cały sam przepływ rozdzielczości, a następnie omówimy jego części krok po kroku:\"},{\"type\":\"list-numeric\",\"items\":[\"Klient wysyła rekurencyjne zapytanie do swojego lokalnego rekurencyjnego buforującego serwera DNS dla adresu IP <b>\\\"cloudflare.com\\\"</b>.\",\"Rekurencyjny buforujący serwer DNS wysyła iteracyjne zapytanie do katalogu głównego (<b>\\\".\\\"</b>) serwer nazw dla adresu IP <b>\\\"cloudflare.com\\\"</b>.\",\"Główny serwer nazw odpowiada skierowaniem do serwera nazw TLD strefy <b>\\\".com\\\"</b>.\",\"Rekurencyjny buforujący serwer DNS wysyła iteracyjne zapytanie do <b>\\\".com\\\"</b> serwer nazw TLD dla adresu IP <b>\\\"cloudflare.com\\\"</b>.\",\"Serwer nazw TLD <b>\\\".com\\\"</b> odpowiada skierowaniem do autorytatywnego serwera nazw strefy <b>\\\"cloudflare\\\"</b>.\",\"Rekurencyjny buforujący serwer DNS wysyła iteracyjne zapytanie do <b>\\\"cloudflare\\\"</b> autorytatywnego serwera nazw dla adresu IP <b>\\\"cloudflare.com\\\"</b>.\",\"<b>\\\"cloudflare\\\"</b> autorytatywny serwer nazw odpowiada adresem IP dla <b>\\\"cloudflare.com\\\"</b>.\",\"Rekurencyjny buforujący serwer DNS odpowiada oryginalnemu klientowi adresem IP <b>\\\"cloudflare.com\\\" </b> (i buforuje go, jeśli nie ma tego rekordu).\",\"Klient wchodzi w interakcję z serwerem WWW <b>\\\"cloudflare.com\\\"</b>.\"]},{\"type\":\"picture\",\"width\":\"w80\",\"resource\":\"dns_record_request_sequence_recursive_resolver.png\"},{\"type\":\"paragraph\",\"content\":\"Dobra, mądralo, ale o subdomenach, jak na przykład <b>\\\"blog.cloudflare.com\\\"</b>? Nic wielkiego, Sekwencja zostanie rozwinięta dla jeszcze jednego autorytatywnego serwera nazw, który przechowuje adres IP tej subdomeny.\"},{\"type\":\"picture\",\"width\":\"w80\",\"resource\":\"dns_record_request_sequence_cname_subdomain.png\"},{\"type\":\"paragraph\",\"content\":\"Widzę, że masz dużo pytań. Okej, Podzielmy tę sekwencję wyjaśnieniami krok po kroku różnych typów serwerów nazw. Nadszedł czas, aby dowiedzieć się wszystkiego o rolach <b>serwerów DNS i zakończyć wyszukiwanie</b>.\"},{\"type\":\"subtitle\",\"content\":\"Role serwerów DNS i pełne wyszukiwanie\"},{\"type\":\"paragraph\",\"content\":\"Pierwszą rzeczą, którą musisz zrozumieć, jest to, że wszystkie te serwery nazw, takie jak root, TLD i bla-bla-bla, to tylko role. Dosłownie może to być tylko jedna fizyczna maszyna (wirtualna lub Nie), która jest odpowiedzialna za obsługę prawie każdego kroku opisanej powyżej sekwencji. Poza tym chyba już zauważyłeś, że istnieje jakaś <b>hierarchia</b> serwerów DNS i to prawda. Wszystkie role DNS są miejscami w hierarchii, która idzie w górę od dołu.\"},{\"type\":\"paragraph\",\"content\":\"Nawiasem mówiąc, <b>rozważmy, że nie ma buforowania na każdym kroku sekwencji</b>. Powinieneś wiedzieć, że <b>buforowanie</b> jest prawdopodobnie jedną z najważniejszych funkcji całego DNS. Chcemy składać jak najmniej wniosków, aby utrzymać wysoką wydajność systemu. Buforowanie odbywa się dosłownie na każdym etapie przepływu rozdzielczości DNS.\"},{\"type\":\"paragraph\",\"content\":\"Zaktualizujmy też trochę naszą sekwencję i pozwólcie, że przedstawię cały <b>przepływ wyszukiwania DNS</b>. Pamiętaj tylko o tym obrazie i wróć do niego po przeczytaniu o każdej roli, aby ukończyć ten obraz w głowie i zrozumieć każdy krok i rolę wyszukiwania DNS.\"},{\"type\":\"picture\",\"width\":\"w100\",\"resource\":\"what_is_a_dns_server_dns_lookup.png\"},{\"type\":\"paragraph\",\"content\":\"Tak więc pierwszą rzeczą, którą spełnia Twoje zapytanie DNS, jest <b>DNS Stub Resolver</b>.\"},{\"type\":\"subsubtitle\",\"content\":\"DNS Stub Resolver\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS Stub Resolver</b> — jest składnikiem pośrednim pomiędzy aplikacją, która wymaga rozpoznawania DNS i rekurencyjnego rozpoznawania DNS. Resolver odcinkowy DNS jest zwykle używany przez urządzenia użytkowników końcowych, takie jak laptopy, smartfony i inne urządzenia sieciowe, do wyszukiwania nazw domen witryn internetowych i innych usług online.\"]},{\"type\":\"paragraph\",\"content\":\"Resolver DNS na poziomie systemu operacyjnego jest drugim i ostatnim przystankiem lokalnym, zanim zapytanie DNS opuści komputer. Proces w systemie operacyjnym, który jest przeznaczony do obsługi tego zapytania, jest powszechnie nazywany <b>\\\"stub resolver\\\"</b> lub <b>klient DNS</b>. Gdy resolver pośredni otrzymuje żądanie z aplikacji, najpierw sprawdza własną pamięć podręczną, aby sprawdzić, czy ma rekord. Jeśli tak się nie stanie, wysyła zapytanie DNS (z ustawioną flagą rekurencyjną) poza siecią lokalną do rekurencyjnego resolwera DNS wewnątrz dostawcy usług internetowych (ISP).\"},{\"type\":\"paragraph\",\"content\":\"Myślę, że masz uwagi, że na zdjęciach nie ma resolwera odcinka, ale to w porządku. Jest to krok między Klientem a rekurencyjnym resolwerem DNS. Zasadniczo jest to krok, w którym klient sprawdza, czy ma już buforowany adres IP żądanej nazwy domeny. Ponadto, dla lepszego zrozumienia, zaznaczmy wszystkie kroki, w których zaangażowana jest ta rola. Powiedzmy, że jest to <b>krok 0</b>.\"},{\"type\":\"subsubtitle\",\"content\":\"Rekurencyjny mechanizm rozpoznawania nazw DNS\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Rekurencyjny Resolver DNS</b> — rekurencyjny resolver jest komponentem odpowiedzialnym za odpowiedzi na rekurencyjne żądanie klienta i poświęcenie czasu na wyśledzenie rekordu DNS (Zwykle 24 godziny). Wykonuje zadanie rozwiązywania zapytań DNS poprzez rekurencyjne przechodzenie przez hierarchię DNS. Gdy rekurencyjny resolver otrzyma zapytanie DNS od klienta, wyśle zapytanie do innych serwerów DNS w imieniu klienta, aby rozwiązać nazwę domeny na adres IP.\"]},{\"type\":\"paragraph\",\"content\":\"<b>Rekurencyjny Resolver DNS jest łącznikiem całego przepływu.</b>\"},{\"type\":\"paragraph\",\"content\":\"Jedną z kluczowych zalet korzystania z rekurencyjnego resolwera jest to, że może on <b>buforować</b> rekordy DNS w celu poprawy wydajności kolejnych zapytań DNS. Dlatego też będzie odnosić się do niego jako <b>serwer buforowania DNS</b>. Gdy rekurencyjny resolver otrzyma odpowiedź DNS, będzie przechowywał odpowiedź w swojej pamięci podręcznej przez pewien czas (znany jako time-To-live lub TTL), aby mógł szybko odpowiedzieć na przyszłe zapytania dotyczące tej samej nazwy domeny. Może to pomóc zmniejszyć obciążenie systemu DNS i poprawić wydajność wyszukiwań DNS.\"},{\"type\":\"paragraph\",\"content\":\"Tutaj wszystko się zaczyna. Klient (użytkownik końcowy) wysyła rekurencyjne zapytanie do swojego lokalnego rekurencyjnego buforowania serwera DNS dla <b>cloudflare.com</b>. to jest <b>Krok 1</b>\"},{\"type\":\"subsubtitle\",\"content\":\"Główny serwer nazw DNS\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS Root Nameserver</b> — główny serwer nazw <b>(DNS Root Nameserver ≠ DNS Root Server!!! Omówimy to później)</b> jest pierwszym krokiem w tłumaczeniu (rozwiązywaniu) czytelnych dla człowieka nazw hostów na adresy IP. Pamiętasz tę kropkę w nazwie domeny, to nie była literówka? Tutaj w grę wchodzi root nameserver.\"]},{\"type\":\"paragraph\",\"content\":\"Rekurencyjny serwer buforowania wysyła iteracyjne zapytanie do katalogu głównego <b>\\\".\\\"</b> serwer nazw dla <b>\\\"cloudflare.com\\\"</b> - <b>Krok 2</b>. Główny serwer nazw odpowiada skierowaniem do serwera nazw strefy <b>\\\".com\\\"</b>. Ale co to jest <b>\\\".com\\\"</b>, oczywiście jest to domena najwyższego poziomu! Serwer główny odpowiada skierowaniem do serwerów nazw TLD strefy <b>\\\".com\\\"</b>.\"},{\"type\":\"subsubtitle\",\"content\":\"Serwer nazw DNS TLD\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Serwer nazw DNS TLD</b> — TLD oznacza domenę najwyższego poziomu. Serwer nazw TLD przechowuje informacje dla wszystkich nazw domen, które mają wspólne rozszerzenie domeny, takich jak <b>\\\".com\\\"</b>, <b>\\\".net\\\"</b> lub cokolwiek pojawia się po ostatniej kropce w adresie URL. Na przykład serwer nazw TLD <b>\\\".com\\\"</b> zawiera informacje dla każdej witryny, która kończy się na <b>\\\".com \\\"</b>.\"]},{\"type\":\"paragraph\",\"content\":\"Rekurencyjny buforujący serwer DNS wysyła iteracyjne zapytanie do <b>\\\".com\\\"</b> serwer dla cloudflare.com - <b>Krok 4</b>. Serwer nazw TLD odpowiada skierowaniem do autorytatywnego serwera nazw cloudflare zone- <b>Krok 5</b>.\"},{\"type\":\"subsubtitle\",\"content\":\"Autorytatywny serwer nazw DNS\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS autorytatywny serwer nazw</b> — ten ostateczny serwer nazw można traktować jako słownik na stojaku z książkami, w którym można przetłumaczyć określoną nazwę na jej definicję. Autorytatywny serwer nazw jest ostatnim przystankiem w zapytaniu serwera nazw. Jeśli autorytatywny serwer nazw ma dostęp do żądanego rekordu, zwróci adres IP żądanej nazwy hosta z powrotem do serwera DNS, który złożył wstępne żądanie.\"]},{\"type\":\"paragraph\",\"content\":\"Rekurencyjny buforujący serwer DNS wysyła iteracyjne zapytanie do <b>\\\"cloudflare\\\"</b> serwer dla <b>\\\"cloudflare.com\\\"</b> — <b>Krok 6</b>. <b>\\\"cloudflare.com\\\"</b> autorytatywny serwer nazw odpowiada adresem IP dla <b>\\\"cloudflare.com\\\"</b> — <b>Krok 7</b>. Rekurencyjny buforujący serwer DNS odpowiada oryginalnemu klientowi adresem IP <b>\\\"cloudflare.com\\\"</b> - <b>Krok 8</b> — i klient wchodzi w interakcję z serwerem WWW <b>\\\"cloudflare.com\\\"</b> — <b>Kroki 9 i 10 </b>.\"},{\"type\":\"paragraph\",\"content\":\"Dobra robota, to wszystko o wyszukiwaniach DNS. Teraz wiesz, jak to działa i jakie komponenty są zaangażowane. Prawdopodobnie zauważyłeś, że istnieje wiele \\\"serwerów DNS\\\". Kiedy mówię \\\"serwer DNS\\\", dosłownie mam na myśli cały ten przepływ, ponieważ serwer DNS po prostu łączy się we wszystkich rolach.\"},{\"type\":\"subsubtitle\",\"content\":\"DNS Root Nameserver vs DNS Root Server\"},{\"type\":\"paragraph\",\"content\":\"Pamiętaj, że na zdjęciu zatytułowanym <b>kompletne wyszukiwanie DNS i Zapytanie o stronę internetową </b>. Na tym zdjęciu jest jeden wielki błąd. Widzisz, Krok 2 i 3 mówią o komunikacji z <b>głównym serwerem DNS </b>,ale w rzeczywistości jest to <b>główny serwer nazw DNS</b>. Niezwykle ważne jest, aby je różnić. Pozwól, że wyjaśnię różnicę:\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Serwery główne DNS</b> — to 13 autorytatywnych serwerów nazw, które są odpowiedzialne za odpowiadanie na zapytania dotyczące strefy głównej systemu nazw domen (DNS). Serwery te są obsługiwane przez różne organizacje na całym świecie i są identyfikowane literami od A Do M. są pierwszym krokiem w procesie rozwiązywania nazwy domeny na adres IP i pomagają skierować ruch do odpowiedniego serwera nazw domeny najwyższego poziomu (TLD).\",\"<b>DNS Root Nameservers</b> — zestaw serwerów nazw, które obsługują strefę główną DNS. Te serwery nazw są odpowiedzialne za dostarczanie skierowań do serwerów nazw TLD i innych autorytatywnych serwerów nazw i odgrywają kluczową rolę w funkcjonowaniu DNS. Termin \\\"główny serwer nazw\\\" jest często używany zamiennie z \\\"głównym serwerem\\\", ale ściśle mówiąc, ten pierwszy odnosi się konkretnie do serwerów nazw, które obsługują strefę główną.\"]},{\"type\":\"subtitle\",\"content\":\"Typy rekordów DNS\"},{\"type\":\"paragraph\",\"content\":\"Na początku naszej ścieżki powiedziałem, że do pewnego momentu powinniśmy traktować DNS jako coś, co konwertuje adresy URL na adresy IP stron internetowych. Technicznie jest to prawda, ale tylko częściowo. DNS jest odpowiedzialny za konwersję <b>każdej czytelnej dla człowieka nazwy zasobu na adres IP</b>. Obejmuje nie tylko strony internetowe (IPv4 i IPv6), ale także na przykład serwery poczty e-mail. Są to tak zwane <b>typy rekordów DNS</b>. Omówmy krótko najważniejsze z nich.\"},{\"type\":\"subsubtitle\",\"content\":\"A Rekord (address)\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Rekord A (adres)</b> — pokazuje adres IP dla określonej nazwy hosta lub domeny. Działa tylko dla typu IPv4. Głównym jego zastosowaniem jest wyszukiwanie adresu IP. Korzystając z rekordu a, przeglądarka internetowa może załadować stronę internetową przy użyciu nazwy domeny.\"]},{\"type\":\"subsubtitle\",\"content\":\"AAAA Rekord (quad A)\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Rekord AAAA (quad A)</b> — tak jak rekord wskazuje adres IP domeny, kup zamiast używać IPv4, używa IPv6. Główne użycie if jest takie samo jak w przypadku typu, ale rozwiązuje nazwę domeny na nowszy adres protokołu IPv6. Telefony komórkowe preferują IPv6, jeśli jest dostępny.\"]},{\"type\":\"subsubtitle\",\"content\":\"MX Rekord (Mail eXchange)\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Rekord MX (Wymiana poczty)</b> — umożliwia kierowanie wiadomości e-mail do serwera pocztowego, pokazując, gdzie wiadomości e-mail dla domeny powinny być kierowane. Możesz mieć wiele rekordów MX dla jednej nazwy domeny-w zasadzie wystarczy wykonać kopię zapasową poczty e-mail. Im niższa wartość priorytetu dla serwera,tym ważniejsza. A w przypadku awarii serwera podstawowego zostanie użyty serwer dodatkowy-aktywny-aktywny schemat.\"]},{\"type\":\"paragraph\",\"content\":\"Głównym jego zastosowaniem jest mapowanie, gdzie należy dostarczyć wiadomość e-mail. Powinien wskazywać nazwę serwera pocztowego, a nie adres IP. <b>ANAME</b> — może wskazywać nazwę serwera pocztowego lub adres IP.\"},{\"type\":\"subsubtitle\",\"content\":\"NS Rekord (nameserver)\"},{\"type\":\"list-bullet\",\"items\":[\"<b>NS Record (nameserver)</b> — określa autorytatywny serwer DNS dla domeny. Innymi słowy, rekord NS pomaga wskazać, gdzie aplikacja internetowa, taka jak przeglądarka internetowa, może znaleźć adres IP nazwy domeny. Zwykle dla domeny określa się wiele serwerów nazw. Głównym zastosowaniem tych autorytatywnych serwerów jest połączenie nazwy domeny z rzeczywistym serwerem, na którym hostowana jest Twoja witryna. Serwery nazw zawierają inne rekordy DNS, takie jak rekordy MX lub A.\"]},{\"type\":\"subsubtitle\",\"content\":\"CNAME Rekord (Canonical Name)\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Rekord CNAME (Nazwa kanoniczna)</b> — to rekord DNS, który wskazuje nazwę domeny (alias) na inną domenę. W rekordzie CNAME alias nie wskazuje adresu IP. A nazwa domeny, na którą wskazuje alias, to nazwa kanoniczna.\"]},{\"type\":\"paragraph\",\"content\":\"Na przykład subdomena ng.example.com (ng.example.com jest rekordem CNAME) może wskazywać na example.com korzystanie z CNAME. Tutaj example.com wskazuje Rzeczywisty adres IP za pomocą rekordu A.\"},{\"type\":\"paragraph\",\"content\":\"Głównym jego zastosowaniem jest uruchamianie wielu subdomen do różnych celów na tym samym serwerze. Na przykład mamy ftp.example.com oraz www.example.com. możemy następnie użyć rekordu CNAME, aby wskazać obie subdomeny example.com. domena główna example.com następnie wskazuje adres IP serwera za pomocą rekordu A. Możliwe jest również, że jedna nazwa CNAME wskazuje inną nazwę. Jest to jednak nieefektywne i może prowadzić do niskiej prędkości ładowania i słabego doświadczenia użytkownika.\"},{\"type\":\"paragraph\",\"content\":\"Zwykle wskazuje na load balancer.\"},{\"type\":\"subsubtitle\",\"content\":\"ANAME Rekord\"},{\"type\":\"list-bullet\",\"items\":[\"<b>ANAME (ALIAS)</b> — połączenie CNAME i typów rekordów A. Nazwa nie jest odczytywanym rekordem DNS, ale sposobem na jego symulację. I dlatego nazywa się to nazwą aliasu. Podobnie jak CNAME, ANAME odwzorowuje jedną nazwę domeny na drugą. Tak więc ANAME jest skonfigurowana do wskazywania innej domeny. Gdy nazwa domeny, na którą wskazuje ANAME, jest odpytywana przez przeglądarkę klienta, odpowiada adresem IP. Z drugiej strony CNAME nie może wskazywać adresu IP, ale ANAME może.\"]},{\"type\":\"paragraph\",\"content\":\"Był używany w przeszłości, CNAME jest obecnie królem. Nie powinien wskazywać na load balancer.\"},{\"type\":\"subsubtitle\",\"content\":\"TXT Rekord\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Rekord TXT (rekord tekstowy)</b> — to typ rekordu, który umożliwia administratorowi dodawanie notatek czytelnych dla człowieka (i do odczytu maszynowego) w DNS. Nie wymaga określonego formatu. Służy do zapewnienia możliwości kojarzenia dowolnego tekstu z hostem lub inną nazwą, taką jak czytelne dla człowieka informacje o serwerze, sieci, centrum danych lub inne informacje księgowe.\"]},{\"type\":\"paragraph\",\"content\":\"Głównym zastosowaniem tego w dzisiejszych czasach jest zapobieganie spamowi e-mailowemu i weryfikacja własności domeny. Tutaj powinniśmy porozmawiać o DMARC, SPF i DKIM, ale na razie po prostu wiedz, że chodzi o <b>bezpieczeństwo antyspamowe</b>.\"},{\"type\":\"title\",\"content\":\"Problemy z bezpieczeństwem DNS\"},{\"type\":\"paragraph\",\"content\":\"Okej, teraz mamy pełny przegląd tego, jak działa rozpoznawanie DNS, jakie są różne role serwerów DNS, a nawet wspomnieliśmy o kilku głównych typach rekordów, ale co z kwestiami bezpieczeństwa? W rzeczywistości mamy tylko 2 główne problemy z bezpieczeństwem - <b>brak uwierzytelnienia i poufności</b>.\"},{\"type\":\"paragraph\",\"content\":\"Pierwszy wynika z faktu, że DNS nie ma możliwości sprawdzenia, czy żądany rekord pochodzi z zaufanego źródła, a ten problem jest łagodzony przez <b>DNSSEC</b>.\"},{\"type\":\"paragraph\",\"content\":\"Drugi wynika z faktu, że DNS jako protokół został zaimplementowany na początku lat 80-tych. jak już wiesz, w tym czasie bezpieczeństwo nie było na pierwszym planie, podczas gdy wszystkie zasoby koncentrowały się na zapewnieniu tylko dostępności. Dlatego DNS, podobnie jak wiele innych protokołów, takich jak HTTP lub ART, przesyła dane w postaci zwykłego tekstu. Ten problem jest łagodzony przez <b>szyfrowanie </b>.\"},{\"type\":\"paragraph\",\"content\":\"Dobrze, zdecydowanie omówimy oba problemy, ale najpierw przyjrzyjmy się, jak wygląda DNS, gdy został zhakowany:\"},{\"type\":\"list-numeric\",\"items\":[\"Klient wysyła rekurencyjne zapytanie do swojego lokalnego rekurencyjnego buforującego serwera DNS dla adresu IP <b>\\\"cloudflare.com\\\"</b>.\",\"Rekurencyjny buforujący serwer DNS wysyła iteracyjne zapytanie do katalogu głównego (<b>\\\".\\\"</b>) serwer nazw dla adresu IP <b>\\\"cloudflare.com\\\"</b>.\",\"Główny serwer nazw odpowiada skierowaniem do serwera nazw TLD strefy <b>\\\".com\\\"</b>.\",\"Rekurencyjny buforujący serwer DNS wysyła iteracyjne zapytanie do <b>\\\".com\\\"</b> serwer nazw TLD dla adresu IP <b>\\\"cloudflare.com\\\"</b>.\",\"Serwer nazw TLD <b>\\\".com\\\"</b> odpowiada skierowaniem do autorytatywnego serwera nazw strefy <b>\\\"cloudflare\\\"</b>.\",\"Rekurencyjny buforujący serwer DNS wysyła iteracyjne zapytanie do <b>\\\"cloudflare\\\"</b> autorytatywnego serwera nazw dla adresu IP <b>\\\"cloudflare.com\\\"</b>.\",\"Zły serwer DNS odpowiada złym adresem IP dla <b>\\\"cloudflare.com\\\" </b>.\",\"Rekurencyjny buforujący serwer DNS odpowiada oryginalnemu klientowi złym adresem IP dla <b>\\\"cloudflare.com\\\"</b>.\",\"Klient wchodzi w interakcję ze złym serwerem WWW, który albo odpowiada bezpośrednio, albo wykonuje operację ataku typu <b>Man-in-the-Middle</b>, przekazując i obserwując (lub zmieniając) ruch z/na legalny serwer WWW.\"]},{\"type\":\"picture\",\"width\":\"w70\",\"resource\":\"dns_poisoning.jpeg\"},{\"type\":\"paragraph\",\"content\":\"Jak widać, od kroku 1 do 6 mamy dokładnie ten sam przepływ, problemy zaczynają się od kroku 7.\"},{\"type\":\"paragraph\",\"content\":\"Nazywa się to <b>DNS spoofing/Cache poisoning</b> — jest to atak, w którym sfałszowane dane DNS są wprowadzane do pamięci podręcznej resolwera DNS, w wyniku czego resolver zwraca nieprawidłowy adres IP dla domeny. Zamiast przejść do właściwej strony internetowej, ruch może zostać przekierowany na złośliwą maszynę lub gdziekolwiek indziej, czego chce atakujący; często będzie to replika oryginalnej witryny używanej do złośliwych celów, takich jak dystrybucja złośliwego oprogramowania lub zbieranie danych logowania.\"},{\"type\":\"paragraph\",\"content\":\"Musimy więc jakoś sprawdzić, czy odpowiedź pochodzi z zaufanego źródła, prawda? Zasadniczo zapewnij  <b>uwierzytelnianie</b> — tutaj w grę wchodzi <b>DNSSEC</b>.\"},{\"type\":\"title\",\"content\":\"Przegląd DNSSEC\"},{\"type\":\"paragraph\",\"content\":\"Wreszcie, oto jesteśmy, DNSSEC! Powinniśmy wziąć pod uwagę, że DNS i DNSSEC są teraz jak HTTP i HTTPS ~20 lat temu. Będzie to wymagane przez wszystkich w celu zapewnienia bezpiecznej komunikacji. DNSSEC i HTTPS są nawet podobne w niektórych przypadkach.\"},{\"type\":\"paragraph\",\"content\":\"HTTPS zapewnia zarówno <b>uwierzytelnianie</b>, jak i <b>poufność</b> przy użyciu infrastruktury PKI CA (jeśli nie znasz <a href='https://blog.mikhailbahdashych.me/en/blog/pki-infrastructure-or-how-to-build-your-own-vpn' class='inline-link non-en'> zobacz tutaj</a>).<b>Uwierzytelnianie</b> zapewnia weryfikacja, kto był wystawcą certyfikatu, natomiast <b>poufność</b> zapewnia szyfrowanie ruchu.\"},{\"type\":\"paragraph\",\"content\":\"W przypadku DNSSEC zapewnia tylko <b>uwierzytelnianie</b>, gdzie szyfrowanie DNS zapewnia <b>poufność</b>, o czym już wspomniano powyżej. Ale wracając do DNSSEC, zacznijmy od prostej definicji tego, czym tak naprawdę jest:\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNSSEC (DNS Security Extension)</b> — to mechanizm uwierzytelniania, który wykorzystuje kryptografię PKI, aby zapobiec fałszowaniu. W przypadku DNSSEC nie są to zapytania DNS, a same odpowiedzi są podpisane kryptograficznie, ale same dane DNS podpisane przez właściciela danych.\"]},{\"type\":\"paragraph\",\"content\":\"Pamiętasz, gdzie wspomnieliśmy, że DNS ma strukturę hierarchiczną? Przykład DNSSEC sprawi, że będzie to jeszcze bardziej oczywiste. Zakładając, że znasz już PKI i kryptografię, musimy wprowadzić kilka nowych terminów, szczególnie dla DNSSEC.\"},{\"type\":\"subtitle\",\"content\":\"Terminologia DNSSEC\"},{\"type\":\"list-bullet\",\"items\":[\"<b>RRSet - zestaw rekordów zasobów</b> — pierwszym krokiem do zabezpieczenia strefy za pomocą DNSSEC jest zgrupowanie wszystkich rekordów tego samego typu w zestaw rekordów zasobów (RRset). Na przykład, jeśli masz trzy rekordy AAAA w swojej strefie na tej samej etykiecie (tj. label.example.com), wszystkie byłyby połączone w jeden zestaw AAAA RRset.\\n\\nW rzeczywistości jest to pełny RRSet, który jest podpisywany cyfrowo, w przeciwieństwie do indywidualnych rekordów DNS. Oczywiście oznacza to również, że musisz zażądać i zweryfikować wszystkie rekordy AAAA ze strefy o tej samej etykiecie, zamiast walidować tylko jeden z nich. W skrócie - <b>zbiór rekordów o tym samym typie i tej samej domenie/strefie</b>.\"]},{\"type\":\"picture\",\"width\":\"w80\",\"resource\":\"diagram-rrsets.svg\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNSKEY</b> — zawiera publiczny klucz podpisywania.\",\"<b>Rrsig - Resource Record Signature</b> — rekord zawierający podpis cyfrowy RRSet.\",\"<b>ZSK — Klucz podpisywania strefy</b> - <b>używany do podpisywania lub weryfikacji rekordów innych niż klucze domeny/strefy (A, AAAA, MX itp.)</b>. W DNSSEC każda strefa ma parę kluczy do podpisywania stref (ZSK), gdzie klucz prywatny podpisuje każdy zestaw RR w strefie, podczas gdy klucz publiczny weryfikuje podpis. Aby zaimplementować DNSSEC, operator strefy używa prywatnego ZSK do tworzenia podpisów cyfrowych dla każdego zestawu Rrsetów i przechowuje je jako rekordy RRSig na swoim serwerze nazw.\\n\\nJednak same rekordy RRSig nie mogą być używane przez resolwery DNS do weryfikacji podpisów. Aby to włączyć, operator strefy dodaje swój publiczny ZSK do swojego serwera nazw w rekordzie DNSKEY.\\n\\nGdy resolver DNSSEC żąda typu rekordu, serwer nazw zwraca odpowiedni RRSig wraz z zestawem RRset. Resolver może następnie pobrać publiczny ZSK z rekordu DNSKEY na serwerze nazw. RRset, RRSig i public ZSK razem mogą potwierdzić odpowiedź.\\n\\nZaufanie do klucza podpisywania strefy w rekordzie DNSKEY oznacza również zaufanie do wszystkich rekordów w strefie. Ale jeśli ZSK zostanie naruszony, ważne jest, aby zweryfikować publiczny ZSK, aby zapewnić bezpieczeństwo.\"]},{\"type\":\"picture\",\"width\":\"w60\",\"resource\":\"diagram-zone-signing-keys-2.svg\"},{\"type\":\"list-bullet\",\"items\":[\"<b>KSK — Klucz podpisywania klucz</b> - <b>używany do podpisywania lub weryfikacji kluczy domeny/strefy</b>. Oprócz klucza podpisywania strefy serwery nazw DNSSEC wykorzystują Klucz podpisywania klucza (KSK). Podobnie jak ZSK zapewnił bezpieczeństwo RRsets w poprzedniej sekcji, KSK zatwierdza rekord DNSKEY, podpisując publiczny ZSK, generując w ten sposób RRSIG dla DNSKEY.\\n\\nPubliczny KSK jest również publikowany w rekordzie DNSKEY przez serwer nazw, podobnie jak publiczny ZSK, co skutkuje DNSKEY RRSet. Zarówno publiczny KSK, jak i publiczny ZSK są podpisane przez prywatny KSK. Umożliwia to resolverom korzystanie z publicznego KSK do sprawdzania poprawności publicznego ZSK.\"]},{\"type\":\"paragraph\",\"content\":\"Walidacja dla resolverów wygląda teraz tak:\"},{\"type\":\"list-numeric\",\"items\":[\"Żądaj żądanego <b>RRSet</b>, który również zwraca odpowiedni <b>RRSig</b> rekord.\",\"Żądaj rekordów DNSKEY, które zawierają <b>publiczne ZSK i KSK</b>, które również zwracają <b>RRSig</b> dla <b>DNSKEY RRSet</b>.\",\"Sprawdź <b>RRSig</b> żądanego <b>RRSet</b> za pomocą <b>publicznego ZSK</b>.\",\"Sprawdź <b>RRSig</b> <b>DNSKEY RRSet</b> za pomocą <b>publicznego KSK</b>.\"]},{\"type\":\"picture\",\"width\":\"w60\",\"resource\":\"diagram-key-signing-keys-2.svg\"},{\"type\":\"paragraph\",\"content\":\"Prawdopodobnie zauważyłeś już hierarchiczną naturę DNS, a to dopiero początek. Jeśli chodzi o KSK, DNSKEY RRSet i odpowiadające mu rekordy RRSig można buforować, aby uniknąć nadmiernych żądań do serwerów nazw DNS.\"},{\"type\":\"paragraph\",\"content\":\"Zastosowanie oddzielnych kluczy do podpisywania stref i kluczy do podpisywania kluczy ma na celu ułatwienie wymiany starego lub skompromitowanego KSK, co omówimy w następnej sekcji. I odwrotnie, zmiana ZSK jest prostszym procesem, umożliwiając użycie mniejszego ZSK bez narażania bezpieczeństwa serwera i zmniejszania ilości danych, które serwer musi przesyłać przy każdej odpowiedzi.\"},{\"type\":\"paragraph\",\"content\":\"Chociaż ustanowiliśmy zaufanie w naszej strefie, DNS jest systemem hierarchicznym, a strefy zazwyczaj działają w połączeniu ze sobą. Klucz podpisywania kluczy jest podpisany sam, co nie dodaje dodatkowego zaufania, więc potrzebujemy sposobu na połączenie zaufania w naszej strefie ze strefą nadrzędną.\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Rekord DS - Delegacja podpisywania</b> — <b>rekord zawierający skrót publicznego KSK domeny podrzędnej/strefy (odcisk palca publicznego KSK dziecka) </b>. W DNSSEC wprowadzono rekord sygnatariusza delegacji (DS) w celu przeniesienia zaufania ze strefy nadrzędnej do strefy podrzędnej. Aby to osiągnąć, operator strefy hashuje publiczny KSK zawarty w rekordzie DNSKEY i udostępnia go strefie nadrzędnej w celu opublikowania jako rekord DS.\\n\\nIlekroć resolver jest kierowany do strefy podrzędnej, Strefa nadrzędna zapewnia również rekord DS. Ten rekord umożliwia resolverom określenie, czy strefa podrzędna jest włączona DNSSEC. Aby zweryfikować publiczny KSK strefy, resolver hashuje go i porównuje z rekordem DS ze strefy nadrzędnej. Jeśli wartości skrótu są zgodne, resolver może bezpiecznie założyć, że publiczny KSK nie został naruszony ani zmieniony, ustanawiając w ten sposób zaufanie do wszystkich rekordów strefy podrzędnej. <b>W ten sposób powstaje łańcuch zaufania w DNSSEC.</b>\"]},{\"type\":\"picture\",\"width\":\"w50\",\"resource\":\"diagram-delegation-signer-records.svg\"},{\"type\":\"list-bullet\",\"items\":[\"<b>Łańcuch zaufania</b> - proces ustanawiania zaufania w strefie i łączenia go ze strefą nadrzędną, wymaga mechanizmu weryfikacji autentyczności rekordu DS. Osiąga się to poprzez cyfrowe podpisanie rekordu DS, podobnie jak każdy inny RRSet, co skutkuje istnieniem odpowiedniego rrsig w strefie nadrzędnej. Proces walidacji tego podpisu jest powtarzany sukcesywnie, aż do publicznego KSK strefy nadrzędnej. Aby potwierdzić autentyczność tego KSK, konieczne jest sprawdzenie rekordu DS rodzica, kontynuując ten proces w łańcuchu zaufania.\"]},{\"type\":\"picture\",\"width\":\"w50\",\"resource\":\"diagram-the-chain-of-trust.svg\"},{\"type\":\"subtitle\",\"content\":\"Przepływ rozpoznawania DNSSEC\"},{\"type\":\"paragraph\",\"content\":\"To było trudne, prawda? Dobra, dość tej terminologii, wszystko lepiej widać na przykładach. Zamierzamy zmodyfikować nasz poprzedni przepływ rozdzielczości DNS, aby był włączony DNSSEC.\"},{\"type\":\"list-numeric\",\"items\":[\"Klient wysyła rekurencyjne zapytanie do swojego lokalnego rekurencyjnego buforującego serwera DNS dla adresu IP <b>\\\"cloudflare.com\\\"</b>.\",\"Rekurencyjny buforujący serwer DNS wysyła iteracyjne zapytanie do katalogu głównego (<b>\\\".\\\"</b>) serwer nazw dla adresu IP <b>\\\"cloudflare.com\\\"</b>.\",\"Główny serwer nazw:\",[\"Wysyła skierowanie:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"Niezabezpieczone skierowanie do autorytatywnego serwera nazw TLD dla strefy <b>\\\".com\\\"</b>.\"]},\"Wysyła rekord:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>RRSet rekordów DNSKEY</b> dla strefy głównej - <B>publiczny ZSK i publiczny KSK</b> strefy głównej.\",\"<b>RRSig</b> powyższego zestawu rekordów - podpisany przy użyciu <b>prywatnego KSK strefy głównej</b>.\",\"<b>Rekord DS</b> dla strefy <b>\\\".com\\\"</b> - skrót/odcisk palca publicznego KSK strefy \\\".com\\\".\",\"<b>RRSig</b> z powyższego rekordu DS - podpisany przy użyciu prywatnego ZSK strefy głównej.\"]}],\"Rekurencyjny buforujący serwer DNS:\",[\"Weryfikuje rekord:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>DNSKEY RRSet</b> strefy <b>root</b> jest weryfikowany przez pomyślne odszyfrowanie RRSet RRSig przy użyciu publicznego KSK strefy root.\",\"<b>Root</b> rekord DS strefy dla <b>\\\".com\\\"</b> strefa jest weryfikowana przez pomyślne odszyfrowanie RRSig rekordu przy użyciu publicznego ZSK strefy <b>root</b>.\"]},\"Weryfikuje strefę:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"Rekurencyjne buforowanie serwera DNS ma już zaufaną kopię głównego publicznego KSK, którą uzyskał za pomocą innych środków niż protokół DNS (na przykład od dostawcy systemu operacyjnego serwera). Strefa główna jest weryfikowana przez rekurencyjny buforujący serwer DNS, gdy kopia głównego publicznego KSK serwera jest zgodna z kopią dostarczoną serwerowi przez główny serwer DNS.\"]}],\"Rekurencyjny buforujący serwer DNS wysyła iteracyjne zapytanie do <b>\\\".com\\\"</b> serwera nazw TLD dla <b>\\\"cloudflare.com\\\"</b>.\",\"<b>\\\".com\\\"</b> serwer nazw TLD:\",[\"Wysyła skierowanie:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"Niezabezpieczone skierowanie dla autorytatywnego serwera nazw strefy <B>\\\"cloudflare\\\"</b>\"]},\"Wysyła rekordy:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>RRSet rekordów DNSKEY</b> dla strefy \\\".com\\\" - strefa \\\".com\\\" jest <b>publicznym ZSK i publicznym KSK</b>.\",\"<b>RRSig</b> powyższego zestawu rekordów - podpisany przy użyciu <b>prywatnego KSK</b> \\\".com\\\".\",\"<b>Rekord DS</b> dla strefy <b>\\\"cloudflare\\\"</b> - skrót/odcisk palca publicznego KSK strefy \\\"cloudflare\\\".\",\"<b>RRSig</b> z powyższego rekordu DS - podpisany przy użyciu prywatnego ZSK strefy \\\".com\\\".\"]}],\"Rekurencyjny buforujący serwer DNS:\",[\"Weryfikuje zapisy:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>\\\".com\\\" DNSKEY RRSet</b> jest weryfikowany przez pomyślne odszyfrowanie RRSet RRSig przy użyciu publicznego KSK strefy \\\".com\\\"\",\"<b>\\\".com\\\"</b> rekord DS strefy dla <b>\\\"cloudflare\\\"</b> strefa jest weryfikowana przez pomyślne odszyfrowanie RRSig rekordu za pomocą publicznego ZSK strefy <b>\\\".com\\\"</b>.\"]},\"Weryfikuje strefę:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"Strefa <b>\\\".com\\\"</b> jest weryfikowana przez porównanie skrótu/odcisku palca publicznego KSK strefy <b>\\\".com\\\"</b> ze strefy <b>\\\".com\\\"</b> z wcześniej uzyskanym rekordem DS ze strefy głównej dla strefy <b>\\\".com\\\"</b>.\"]}],\"Rekurencyjny buforujący serwer DNS wysyła iteracyjne zapytanie do autorytatywnego serwera nazw \\\"cloudflare\\\" dla \\\"cloudflare.com\\\"\",\"Autorytatywny serwer nazw \\\"cloudflare\\\":\",[\"Sends the records:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>RRSet rekordów DNSKEY</b> dla strefy <b>\\\"cloudflare\\\"</b> - publicznego ZSK strefy <b>\\\"cloudflare\\\"</b> i publicznego KSK.\",\"<b>RRSig</b> powyższego zestawu rekordów - podpisany przy użyciu <b>\\\"cloudflare\\\"</b> prywatnego KSK.\",\"<b>RRSet rekordów A</b> ze strefy <b>\\\"cloudflare\\\"</b>.\",\"<b>RRSig</b> powyższego rekordu DS - podpisany przy użyciu <b>\\\"cloudflare\\\"</b> prywatnego ZSK strefy.\"]}],\"Rekurencyjny buforujący serwer DNS:\",[\"Weryfikuje zapisy:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"<b>\\\"cloudflare\\\" DNSKEY RRSet</b> jest weryfikowany przez pomyślne odszyfrowanie rrset RRSig przy użyciu publicznego KSK strefy <b>\\\"cloudflare\\\"</b>.\",\"<b>\\\"cloudflare\\\" RRSet</b> jest weryfikowany przez pomyślne odszyfrowanie RRSet RRSig przy użyciu publicznego ZSK strefy <b>\\\"cloudflare\\\"</b>.\"]},\"Weryfikuje strefę:\",{\"style\":\"no-margin\",\"type\":\"list-bullet\",\"items\":[\"Strefa <b>\\\"cloudflare\\\"</b> jest weryfikowana przez porównanie skrótu/odcisku palca publicznego KSK <b>\\\"cloudflare\\\"</b> ze strefy <b>\\\"cloudflare\\\"</b> z wcześniej uzyskanym rekordem DS ze strefy głównej dla strefy <b>\\\"cloudflare\\\"</b>.\"]}],\"Rekurencyjny buforujący serwer DNS odpowiada oryginalnemu klientowi adresem IP <b>\\\"cloudflare.com\\\"</b>.\",\"Klient wchodzi w interakcję z serwerem WWW <b>\\\"cloudflare.com\\\" </b>.\"]},{\"type\":\"paragraph\",\"content\":\"Jest jedna rzecz, którą musisz zrozumieć. Wszystkie przedstawione tutaj przykłady dotyczące działania DNS są przykładami akademickimi. Dzieje się tak tylko w sterylnych, \\\"laboratoryjnych\\\" warunkach (w tym przypadku, jeśli nigdzie nie było pamięci podręcznej). Pojęcia te są dość łatwe do zrozumienia, że mają miejsce, w rzeczywistości, jeśli musisz skonfigurować taki system, to dosłownie kilka linii kodu lub zmiana konfiguracji.\"},{\"type\":\"paragraph\",\"content\":\"Takie przykłady są bardziej potrzebne osobom, które projektują sieci i infrastruktury na taką skalę.\"},{\"type\":\"paragraph\",\"content\":\"Mówiąc o samym przykładzie DNS, różne konfiguracje reprezentują różne funkcje. Jak wspomniano powyżej, wszystkie te rekurencyjne resolwery, buforowanie serwera lub głównych serwerów nazw to tylko role, fizycznie może to być jedna maszyna. Dlatego konfiguracja serwera DNS zależy również od tego, co chcesz zbudować. Uważaj więc na wskazówki, które znajdziesz w Internecie.\"},{\"type\":\"title\",\"content\":\"Ceremonia podpisania roota DNSSEC\"},{\"type\":\"paragraph\",\"content\":\"O, w rzeczywistości, aby zrozumieć, jak wszystko działa, nie musisz nic wiedzieć o tej ceremonii, ale wygląda tak fajnie i brzmi tak żałośnie, że nie mogłem się powstrzymać od napisania o tym. <b>Klucze do Internetu</b>, nieźle, co?\"},{\"type\":\"paragraph\",\"content\":\"Prawdopodobnie już zwróciłeś uwagę na to, jak ta hierarchia DNS przechodzi od dołu do góry. W takim przypadku możesz mieć logiczne pytanie: co jest na samej górze?\"},{\"type\":\"paragraph\",\"content\":\"Taki jest cel ceremonii podpisania Root - procedury dotyczącej podpisywania publicznych informacji kluczowania w głównej strefie DNS na kilka następnych miesięcy. Klucz podpisywania prywatnego używany w tym procesie jest dosłownie kluczem do całego Internetu chronionego przez DNSSEC. Publiczna, skontrolowana i ściśle kontrolowana ceremonia dostępu do tego klucza jest koniecznością, aby DNSSEC odniósł sukces jako globalny standard.\"},{\"type\":\"paragraph\",\"content\":\"Po prostu znajdź film z tej ceremonii, ponieważ jest przetłumaczony online i zobacz, skąd pochodzi DNSSEC trust.\"},{\"type\":\"title\",\"content\":\"O szyfrowaniu DNS\"},{\"type\":\"paragraph\",\"content\":\"Jak już się dowiedziałeś, DNSSEC zapewnia tylko uwierzytelnianie, ale nadal przenosi je w postaci zwykłego tekstu. Tutaj w grę wchodzi kryptografia, nasze urocze HTTPS i TLS, które pomogą nam zapewnić nie tylko uwierzytelnianie naszego ruchu, ale także jego poufność.\"},{\"type\":\"subtitle\",\"content\":\"DNS over TLS\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS przez TLS (lub DoT)</b> to standard szyfrowania zapytań DNS, aby zapewnić im bezpieczeństwo i prywatność. DoT używa tego samego protokołu co HTTPS do szyfrowania i uwierzytelniania połączenia. Zwykle DNS działa przez UDP. Co robi DoT, to dodaje szyfrowanie TLS na szczycie protokołu datagram użytkownika (UDP), który jest używany do zapytań DNS. Ponadto zapewnia, że żądania i odpowiedzi DNS nie są naruszane ani fałszowane przez ataki na ścieżce.\"]},{\"type\":\"subtitle\",\"content\":\"DNS over HTTPS\"},{\"type\":\"list-bullet\",\"items\":[\"<b>DNS przez HTTPS (lub DoH)</b> to alternatywny sposób. Zapytania i odpowiedzi DNS są szyfrowane, ale wysyłane za pośrednictwem protokołów HTTP lub HTTP/2 zamiast bezpośrednio przez UDP. Ruch DoH wygląda jak inny ruch HTTPS - np. normalne interakcje użytkownika ze stronami internetowymi i aplikacjami internetowymi — z perspektywy administratora sieci.\"]},{\"type\":\"paragraph\",\"content\":\"W lutym 2020 roku przeglądarka Mozilla Firefox zaczęła domyślnie włączać DoH dla użytkowników w USA. Zapytania DNS z przeglądarki Firefox są szyfrowane przez DoH i przechodzą do Cloudflare lub NextDNS. Kilka innych przeglądarek obsługuje również DoH, chociaż nie jest domyślnie włączony.\"},{\"type\":\"subtitle\",\"content\":\"Różnica między DoT a DoH\"},{\"type\":\"paragraph\",\"content\":\"Główną różnicą między nimi jest <b>jakiego portu używają</b>. DoT używa tylko portu 853, podczas gdy DoH używa 443, który jest portem, z którego korzysta również cały inny ruch HTTPS.\"},{\"type\":\"paragraph\",\"content\":\"Ponieważ DoT ma dedykowany port, każdy, kto ma widoczność sieci, może zobaczyć ruch DoT przychodzący i odchodzący, nawet jeśli same żądania i odpowiedzi są szyfrowane. Natomiast w przypadku Doh zapytania i odpowiedzi DNS są zakamuflowane w innym ruchu HTTPS, ponieważ wszystko przychodzi i odchodzi z tego samego portu.\"},{\"type\":\"paragraph\",\"content\":\"<b>Z punktu widzenia bezpieczeństwa sieci DoT jest prawdopodobnie lepszy</b>. Daje administratorowi sieci możliwość monitorowania i blokowania zapytań DNS, co jest ważne dla identyfikacji i zatrzymywania złośliwej aktywności.\"},{\"type\":\"paragraph\",\"content\":\"<b>Tymczasem zapytania DoH są ukryte w zwykłym ruchu HTTPS</b>, co oznacza, że nie można ich łatwo zablokować bez blokowania całego innego ruchu HTTPS. Jednak z punktu widzenia prywatności Doh jest prawdopodobnie preferowany. Dzięki Doh zapytania DNS są ukryte w większym przepływie ruchu HTTPS. Daje to administratorom sieci mniejszą widoczność, ale zapewnia użytkownikom większą prywatność.\"},{\"type\":\"title\",\"content\":\"Wnioski\"},{\"type\":\"paragraph\",\"content\":\"Podsumowując, DNS (Domain Name System) jest podstawowym elementem Internetu, który służy do tłumaczenia nazw domen na adresy IP. Chociaż DNS ma kluczowe znaczenie dla łączności z Internetem i usług online, jest również podatny na szereg ataków opartych na DNS, w tym zatrucie pamięci podręcznej i fałszowanie DNS.\"},{\"type\":\"paragraph\",\"content\":\"Aby rozwiązać te problemy związane z bezpieczeństwem, DNSSEC (Domain Name System Security Extensions) został opracowany jako protokół bezpieczeństwa, który dodaje warstwę zabezpieczeń kryptograficznych do systemu DNS. Wykorzystując podpisy cyfrowe do weryfikacji autentyczności odpowiedzi DNS, DNSSEC może pomóc w ochronie przed szeregiem ataków związanych z DNS, zapewniając integralność i niezawodność systemu DNS.\"},{\"type\":\"paragraph\",\"content\":\"Chociaż przyjęcie DNSSEC było powolne, staje się ono coraz ważniejsze, ponieważ zagrożenie atakami opartymi na DNS stale rośnie. Organizacje, które polegają na usługach online, powinny rozważyć wdrożenie DNSSEC w celu ochrony swojej obecności w Internecie, poprawy bezpieczeństwa sieci i zmniejszenia ryzyka ataków opartych na DNS. W miarę rozwoju Internetu DNS i DNSSEC pozostaną podstawowymi elementami globalnej sieci, zapewniając niezawodność i bezpieczeństwo usług online przez wiele lat.\"},{\"type\":\"title\",\"content\":\"Kontakt i referencje\"}]",
          references: "[{\"name\":\"Co to jest DNS od Cloudflare\",\"link\":\"https://www.cloudflare.com/en-gb/learning/dns/what-is-dns/\"},{\"name\":\"Co to jest DNSSEC od Cloudflare (oczywiste, prawda?)\",\"link\":\"https://www.cloudflare.com/en-gb/dns/dnssec/how-dnssec-works/\"},{\"name\":\"DNS over TLS vs DNS over HTTPS\",\"link\":\"https://www.cloudflare.com/en-gb/learning/dns/dns-over-tls/\"},{\"name\":\"Zatruwanie i fałszowanie pamięci podręcznej DNS\",\"link\":\"https://www.cloudflare.com/en-gb/learning/dns/dns-cache-poisoning/\"},{\"name\":\"Ludzie, którzy trzymają klucze do Internetu\",\"link\":\"https://www.cloudflare.com/en-gb/dns/dnssec/root-signing-ceremony/\"},{\"name\":\"Dobrze napisany artykuł ICANN o tym, czym jest DNSSEC i dlaczego jest ważny\",\"link\":\"https://www.icann.org/resources/pages/dnssec-what-is-it-why-important-2019-03-05-en\"},{\"name\":\"Naprawdę fajne wideo, które wyjaśnia przepływ rozpoznawania nazw DNS i DNSSEC\",\"link\":\"https://www.youtube.com/watch?v=_8M_vuFcdZU\"}]",
          created_at: new Date(),
          updated_at: new Date()
        }
      ]);

      await queryInterface.bulkInsert('projects', [
        {
          id: uuid.v4(),
          language: 'en',
          title: 'Personal blog',
          slug: 'personal-blog',
          brief: 'How is constructed what you are reading now',
          description: 'The React + Next.js Typescript personal blog and portfolio page web application. The place where I share my thoughts and knowledge.',
          search_tags: ["blog", "typescript", "nextjs"],
          tags: ["blog", "typescript", "nextjs"],
          brief_description: 'You may be wondering how this blog was created from the programming side, so I wanted to give you a brief overview of the tools and technologies I used.',
          license: 'MIT license',
          tech_stack: "[{\"src\":\"javascript\",\"width\":126,\"height\":28},{\"src\":\"typescript\",\"width\":126,\"height\":28},{\"src\":\"react\",\"width\":85,\"height\":28},{\"src\":\"next.js\",\"width\":85,\"height\":28},{\"src\":\"digitalOcean\",\"width\":130,\"height\":28},{\"src\":\"amazon-aws\",\"width\":74,\"height\":28},{\"src\":\"nginx\",\"width\":88,\"height\":28}]",
          project_pages: "[{\"link\":\"https://blog.mikhailbahdashych.me\",\"text\":\"blog.mikhailbahdashych.me\"},{\"link\":\"https://github.com/bl4drnnr/personal-blog\",\"text\":\"github.com/bl4drnnr/personal-blog\"}]",
          toc: "{\"Structure and implementation\":{\"multiLang\":\"Multi-languages\",\"lightDarkThemes\":\"Light/Dark Themes\",\"pageRendering\":\"Page rendering\"},\"secIssues\":\"Security issues\"}",
          content: "[{\"type\":\"title\",\"content\":\"Structure and implementation\"},{\"type\":\"paragraph\",\"content\":\"I think, that the first thing you need to know about the blog is that is the simplest static application. Even though there is no any API or back-end, from which posts would be fetched, you won't see structure page per post. Actually, pages are actually rendered, but from JSON, and it'll be described later.\"},{\"type\":\"subtitle\",\"content\":\"Multi-languages\"},{\"type\":\"paragraph\",\"content\":\"First of all, blog has been written using 3 languages (not programming ones, lol) - Polish, English and Russian. This has been implemented using <span class='code-block'>i18n</span> library (quite obvious, isn't it).\"},{\"type\":\"paragraph\",\"content\":\"In the root folder of the project you will find simple config file called <span class='code-block'>next-i18next.config.js</span> that contains available languages and default languages:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"module.exports = {\\n\\ti18n: {\\n\\t\\tdefaultLocale: 'en',\\n\\t\\tlocales: ['en', 'pl', 'ru'],\\n  },\\n \\treact: { useSuspense: false }\\n};\"},{\"type\":\"paragraph\",\"content\":\"In <span class='code-block'>lib</span> folder, you will find a couple of function that are responsible for the whole translation process. They will be discussed right now, but there is one more thing to mention.\"},{\"type\":\"paragraph\",\"content\":\"In <span class='code-block'>locales</span> folder, you will find a couple of other folders. Looking at their names it is quite understood what they are responsible for. Every folder has the same named JSON files (even the same structure) that contain all text you see in the blog translated on 3 languages. So now you know where everything is stored, and we can get back to lib folder.\"},{\"type\":\"paragraph\",\"content\":\"The first one is <span class='code-block'>language detector</span> contains this (<span class='code-block'>i18conifg</span> is an alias for <span class='code-block'>next-i18next.config.js</span>):\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import languageDetector from 'next-language-detector';\\n\\nimport i18nextConfig from '@i18config';\\n\\nexport default languageDetector({\\n\\tsupportedLngs: i18nextConfig.i18n.locales,\\n\\tfallbackLng: i18nextConfig.i18n.defaultLocale\\n});\"},{\"type\":\"paragraph\",\"content\":\"The above code is just a helper for <span class='code-block'>redirect page</span>. It's just an empty page that is used to check the current language:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import React from 'react';\\n\\nimport { useRouter } from 'next/router';\\n\\nimport languageDetector from './languageDetector';\\n\\nconst useRedirect = (to: any) => {\\n\\tconst router = useRouter();\\n\\tto = to || router.asPath;\\n\\n\\tReact.useEffect(() => {\\n\\t\\tconst detectedLng = languageDetector.detect();\\n\\t\\tif (to.startsWith('/' + detectedLng) && router.route === '/404') {\\n\\t\\t\\trouter.replace('/' + detectedLng + router.route);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// @ts-ignore\\n\\t\\tlanguageDetector.cache(detectedLng);\\n\\t\\trouter.replace('/' + detectedLng + to);\\n\\t});\\n\\n\\treturn <></>;\\n};\\n\\nexport const Redirect = () => {\\n\\t// @ts-ignore\\n\\tuseRedirect();\\n\\treturn <></>;\\n};\"},{\"type\":\"paragraph\",\"content\":\"Probably you have seen, that the route of the blog always looks like that: <span class='code-block'>blog.mikhailbahdashych.com/en</span>. It always starts with the picked language. You will understand why it happens just by taking a look at <span class='code-block'>pages</span> folder.\"},{\"type\":\"picture\",\"width\":\"w30\",\"resource\":\"readme2.png\"},{\"type\":\"paragraph\",\"content\":\"Content of every page outside of <span class='code-block'>[locale]</span> route was replaced by:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import { Redirect } from '@lib/redirect';\\n\\nexport default Redirect;\"},{\"type\":\"paragraph\",\"content\":\"Therefore, every time you are trying to go to wrong route you are either redirected to 404 or main route. Also, in <span class='code-block'>_app.tsx</span> file, to turn on <span class='code-block'>i18n</span> application is exported with <span class='code-block'>appWithTranslation</span> wrapper:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"export default appWithTranslation(App);\"},{\"type\":\"paragraph\",\"content\":\"Last, but not least is <span class='code-block'>getStatic</span> file which is responsible for pages props and getting locale.\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import { serverSideTranslations } from 'next-i18next/serverSideTranslations';\\n\\nimport i18nextConfig from '@i18config';\\n\\nexport const getI18nPaths = () =>\\n\\ti18nextConfig.i18n.locales.map((lang) => ({\\n\\t\\tparams: {\\n\\t\\t\\tlocale: lang\\n\\t\\t}\\n\\t}));\\n\\nexport const getStaticPaths = () => ({\\n\\tfallback: false,\\n\\tpaths: getI18nPaths()\\n});\\n\\nexport async function getI18nProps(ctx: any, ns = ['pages', 'components', 'errors', 'articles']) {\\n\\tconst locale = await ctx?.params?.locale;\\n\\tconst postName = await ctx?.params?.postName || null;\\n\\tconst projectName = await ctx?.params?.projectName || null;\\n\\n\\treturn {\\n\\t\\t...(await serverSideTranslations(locale, ns)),\\n\\t\\tlocale,\\n\\t\\tpostName,\\n\\t\\tprojectName\\n\\t};\\n}\\n\\n\\nexport function makeStaticProps(ns: string[]) {\\n\\treturn async function getStaticProps(ctx: any) {\\n\\t\\treturn {\\n\\t\\t\\tprops: await getI18nProps(ctx, ns)\\n\\t\\t};\\n\\t};\\n}\"},{\"type\":\"paragraph\",\"content\":\"You can see, that it returns <span class='code-block'>locale</span> and, optionally, <span class='code-block'>postName</span> or <span class='code-block'>projectName</span>. It allows us to get <span class='code-block'>locale</span> in props and use it, for instance, in redirect function.\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import { useTranslation } from 'next-i18next';\\nimport { getStaticPaths, makeStaticProps } from '@lib/getStatic';\\n\\ninterface ErrorPageProps {\\n\\tlocale: string;\\n}\\n\\nconst ErrorPage = ({ locale }: ErrorPageProps) => {\\n\\tconst { t } = useTranslation();\\n\\treturn (\\n\\t\\t<>...</>\\n\\t);\\n};\\n\\nconst getStaticProps = makeStaticProps();\\nexport { getStaticPaths, getStaticProps };\\n\\nexport default ErrorPage;\"},{\"type\":\"paragraph\",\"content\":\"Items in array for <span class='code-block'>makeStaticProps</span> function have exact same names as JSON files inside locale folder.\"},{\"type\":\"subtitle\",\"content\":\"Light/Dark Themes\"},{\"type\":\"paragraph\",\"content\":\"Everything is quite easy here. Just <span class='code-block'>Recoil</span> to control the state and localStorage to store the value for color scheme.\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"// src/store/global/global.state.ts\\n\\nimport { atom } from 'recoil';\\n\\nexport const theme = atom<'dark' | 'light'>({\\n\\tkey: 'theme',\\n\\tdefault: 'dark',\\n});\"},{\"type\":\"paragraph\",\"content\":\"Special hook to change the theme:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import { useMemo } from 'react';\\n\\nimport { useRecoilState } from 'recoil';\\n\\nimport { theme as storeTheme } from '@store/global/global.state';\\nimport { DarkTheme } from '@styles/Dark.theme';\\nimport { LightTheme } from '@styles/Light.theme';\\n\\nconst useDarkMode = () => {\\n\\tconst [theme, setTheme] = useRecoilState(storeTheme);\\n\\n\\tconst toggleTheme = () => {\\n\\t\\tsetTheme(theme === 'light' ? 'dark' : 'light');\\n\\t};\\n\\n\\tconst themeMode = useMemo(() => (theme === 'light' ? LightTheme : DarkTheme), [theme]);\\n\\n\\treturn [theme, toggleTheme, themeMode] as const;\\n};\\n\\nexport default useDarkMode;\"},{\"type\":\"paragraph\",\"content\":\"Used in <span class='code-block'>Global.layout.tsx</span> by <span class='code-block'>ThemeProvider</span>:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import React from 'react';\\n\\nimport { ThemeProvider } from 'styled-components';\\n\\nimport useDarkMode from '@hooks/useDarkMode.hook';\\nimport { DarkTheme } from '@styles/Dark.theme';\\nimport { LightTheme } from '@styles/Light.theme';\\n\\nconst GlobalLayout = ({ children, loading = false }: GlobalLayoutProps) => {\\n\\tconst [theme] = useDarkMode();\\n\\n\\treturn (\\n\\t\\t<ThemeProvider theme={theme === 'light' ? LightTheme : DarkTheme}>\\n\\t\\t\\t...\\n\\t\\t</ThemeProvider>\\n\\t);\\n};\\n\\nexport default GlobalLayout;\"},{\"type\":\"paragraph\",\"content\":\"Handler for theme changing has been implemented within <span class='code-block'>Header</span> component.\"},{\"type\":\"paragraph\",\"content\":\"Two themes described in <span class='code-block'>themes</span> folder. They are implementing interface, that describes what fields are allowed to be used:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"export interface ThemeProps {\\n\\tcolors: {\\n\\t\\tprimaryLight: string;\\n\\t\\tprimaryDark: string;\\n\\t\\tlightBackground: string;\\n\\t\\tdarkBackground: string;\\n\\t\\ttextColor: string;\\n\\t\\tsvgColor: string;\\n\\t}\\n}\"},{\"type\":\"subtitle\",\"content\":\"Page rendering\"},{\"type\":\"paragraph\",\"content\":\"As you can see, instead of creating page per post/project only one page per entity has been created. Every page gets the name of the project or post from params and then checks (in environmental variables) check, if page exists it renders it from JSON, in other case it redirects user to 404. Also, it means that every JSON has to be written in certain format.\"},{\"type\":\"paragraph\",\"content\":\"Here is how it looks like:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import React from 'react';\\n\\nimport { useTranslation } from 'next-i18next';\\nimport { useRouter } from 'next/router';\\n\\nimport { makeStaticProps } from '@lib/getStatic';\\n\\ninterface PostProps {\\n\\tlocale: string;\\n\\tpostName: string;\\n}\\n\\nconst BlogPost = ({ locale, postName }: PostProps) => {\\n\\tconst { t } = useTranslation();\\n\\tconst router = useRouter();\\n  \\n\\treturn (\\n\\t\\t<>\\n\\t\\t\\t...\\n\\t\\t\\t<PostParagraph\\n\\t\\t\\t\\tdangerouslySetInnerHTML={{ __html: item }}\\n\\t\\t\\t/>\\n\\t\\t\\t...\\n\\t\\t</>\\n\\t);\\n};\\n\\nexport const getServerSideProps = async (ctx: any) => {\\n\\tconst staticProps = await makeStaticProps()(ctx);\\n\\tconst props = staticProps.props;\\n\\n\\treturn {\\n\\t\\tprops: {\\n\\t\\t\\t...props\\n\\t\\t}\\n\\t};\\n};\\n\\nexport default BlogPost;\"},{\"type\":\"paragraph\",\"content\":\"As it's been mentioned above, the usage of props for post and project page is a little differ from other pages as in those case we also need to get not only <span class='code-block'>locale</span> but <span class='code-block'>postName</span> (or <span class='code-block'>projectName</span>)\"},{\"type\":\"paragraph\",\"content\":\"Have you noticed <span class='code-block'>dangerouslySetInnerHTML</span>, well there is one security issue...\"},{\"type\":\"title\",\"content\":\"Security issues\"},{\"type\":\"paragraph\",\"content\":\"Bruh, security issues?! Yeah, probably you have notices that every blog post is written in JSON format, just specifying all fields and structure of the post itself, like titles, subtitles, code blocks etc. Well, here is the XSS injection attack comes into play. Because I wanted to wrap some text right inside the paragraph just <span class='code-block'>like this</span> for instance, I had to decided how I wanted to do that.\"},{\"type\":\"paragraph\",\"content\":\"I had a couple of ideas on that, the only requirement was that every post has to be within \\\"one-page\\\" structure. Basically, if you take a look at the file structure, as it has been mentioned before, you will find that there is only one page which gets post name from the URL and then just checks (using environmental variables), if the page exists, it \\\"renders\\\" it from JSON, otherwise, it redirects to 404 page.\"},{\"type\":\"picture\",\"width\":\"w50\",\"resource\":\"readme1.png\"},{\"type\":\"paragraph\",\"content\":\"At this point I guess some of you already has figured out what is the issue. If I need to render HTML that is written as text, I need to use <span class='code-block'>dangerouslySetInnerHTML</span> and this is the straight road to XSS, if text comes from untrusted sources and/or not sanitized.\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"<PostParagraph \\n\\tdangerouslySetInnerHTML={{ __html: item }}\\n/>\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"[\\n\\t\\\"Very last step here is checking if our nginx sever is working correctly\\\"\\n]\"},{\"type\":\"paragraph\",\"content\":\"Above you have seen an example of how I render simple paragraph. You can easily inject there <span class='code-block'>script</span> tag and do your dirty things. Fortunately, there is only one source, and it's trusted, and it's me :)\"},{\"type\":\"paragraph\",\"content\":\"As I have mentioned previously, I had a couple of ideas on how to implement that. The way it's been implemented is actually the easiest one. The other quite easy method is simple sanitization. The only thing that would be excluded in this case is <span class='code-block'>script</span> tag. The exact same situation with projects page.\"},{\"type\":\"paragraph\",\"content\":\"The most completed is to create \\\"your own tags\\\" and after pages gets JSON, instead of rendering it at this exact moment, you would pass it to function, that would interpret your tags to normal HTML and return it to the page. Also, it would be the sort of sanitization, as it could be implemented right in that function. Why did I do this way? Well... You know... I'm kinda lazy :)\"}]",
          created_at: new Date(),
          updated_at: new Date()
        },
        {
          id: uuid.v4(),
          language: 'ru',
          title: 'Личный блог',
          slug: 'personal-blog',
          brief: 'Как устроено то, что вы сейчас читаете',
          description: 'Личный блог React + Next.js Typescript и веб-приложение страницы портфолио. Место, где я делюсь своими мыслями и знаниями.',
          search_tags: ["blog", "typescript", "nextjs"],
          tags: ["blog", "typescript", "nextjs"],
          brief_description: 'Вам может быть интересно, как этот блог был создан с точки зрения программирования, поэтому я хотел дать вам краткий обзор инструментов и технологий, которые я использовал.',
          license: 'MIT лизенция',
          tech_stack: "[{\"src\":\"javascript\",\"width\":126,\"height\":28},{\"src\":\"typescript\",\"width\":126,\"height\":28},{\"src\":\"react\",\"width\":85,\"height\":28},{\"src\":\"next.js\",\"width\":85,\"height\":28},{\"src\":\"digitalOcean\",\"width\":130,\"height\":28},{\"src\":\"amazon-aws\",\"width\":74,\"height\":28},{\"src\":\"nginx\",\"width\":88,\"height\":28}]",
          project_pages: "[{\"link\":\"https://blog.mikhailbahdashych.me\",\"text\":\"blog.mikhailbahdashych.me\"},{\"link\":\"https://github.com/bl4drnnr/personal-blog\",\"text\":\"github.com/bl4drnnr/personal-blog\"}]",
          toc: "{\"Структура и реализация\":{\"multiLang\":\"Многоязычность\",\"lightDarkThemes\":\"Светлые/темные темы\",\"pageRendering\":\"Рендеринг страницы\"},\"secIssues\":\"Проблемы с безопасностью\"}",
          content: "[{\"type\":\"title\",\"content\":\"Структура и реализация\"},{\"type\":\"paragraph\",\"content\":\"Я думаю, что первое, что вам нужно знать о блоге, это то, что это самое простое статическое приложение. Несмотря на то, что нет никакого API или серверной части, из которой можно было бы получать сообщения, вы не увидите страницу структуры для каждого поста. На самом деле страницы действительно рендерятся, но из JSON, и это будет описано позже.\"},{\"type\":\"subtitle\",\"content\":\"Многоязычность\"},{\"type\":\"paragraph\",\"content\":\"Во-первых, блог написан на 3-х языках (не программирования, лол) - польском, английском и русском. Это реализовано с помощью библиотеки <span class='code-block'>i18n</span> (весьма очевидно, не так ли).\"},{\"type\":\"paragraph\",\"content\":\"В корневой папке проекта вы найдете простой файл конфигурации с именем <span class='code-block'>next-i18next.config.js</span>, который содержит доступные языки и языки по умолчанию:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"module.exports = {\\n\\ti18n: {\\n\\t\\tdefaultLocale: 'en',\\n\\t\\tlocales: ['en', 'pl', 'ru'],\\n  },\\n \\treact: { useSuspense: false }\\n};\"},{\"type\":\"paragraph\",\"content\":\"В папке <span class='code-block'>lib</span> вы найдете пару функций, отвечающих за весь процесс перевода. О них пойдет речь прямо сейчас, но следует упомянуть еще об одном.\"},{\"type\":\"paragraph\",\"content\":\"В папке <span class='code-block'>locales</span> вы найдете еще пару папок. Глядя на их имена вполне понятно, за что они отвечают. В каждой папке есть файлы JSON с одинаковыми именами (даже с одинаковой структурой), которые содержат весь текст, который вы видите в блоге, переведенный на 3 языка. Итак, теперь вы знаете, где все хранится, и мы можем вернуться к папке lib.\"},{\"type\":\"paragraph\",\"content\":\"Первый — <span class='code-block'>language detector</span> содержит это (<span class='code-block'>i18conifg</span> — это псевдоним для <span class='code-block '>next-i18next.config.js</span>):\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import languageDetector from 'next-language-detector';\\n\\nimport i18nextConfig from '@i18config';\\n\\nexport default languageDetector({\\n\\tsupportedLngs: i18nextConfig.i18n.locales,\\n\\tfallbackLng: i18nextConfig.i18n.defaultLocale\\n});\"},{\"type\":\"paragraph\",\"content\":\"Приведенный выше код является вспомогательным для <span class='code-block'>страницы перенаправления</span>. Это просто пустая страница, которая используется для проверки текущего языка:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import React from 'react';\\n\\nimport { useRouter } from 'next/router';\\n\\nimport languageDetector from './languageDetector';\\n\\nconst useRedirect = (to: any) => {\\n\\tconst router = useRouter();\\n\\tto = to || router.asPath;\\n\\n\\tReact.useEffect(() => {\\n\\t\\tconst detectedLng = languageDetector.detect();\\n\\t\\tif (to.startsWith('/' + detectedLng) && router.route === '/404') {\\n\\t\\t\\trouter.replace('/' + detectedLng + router.route);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// @ts-ignore\\n\\t\\tlanguageDetector.cache(detectedLng);\\n\\t\\trouter.replace('/' + detectedLng + to);\\n\\t});\\n\\n\\treturn <></>;\\n};\\n\\nexport const Redirect = () => {\\n\\t// @ts-ignore\\n\\tuseRedirect();\\n\\treturn <></>;\\n};\"},{\"type\":\"paragraph\",\"content\":\"Наверное, вы видели, что маршрут блога всегда выглядит так: <span class='code-block'>blog.mikhailbahdashych.com/en</span>. Он всегда начинается с выбранного языка. Вы поймете, почему это происходит, просто взглянув на папку <span class='code-block'>pages</span>.\"},{\"type\":\"picture\",\"width\":\"w30\",\"resource\":\"readme2.png\"},{\"type\":\"paragraph\",\"content\":\"Содержимое каждой страницы за пределами маршрута <span class='code-block'>[locale]</span> было заменено на:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import { Redirect } from '@lib/redirect';\\n\\nexport default Redirect;\"},{\"type\":\"paragraph\",\"content\":\"Поэтому каждый раз, когда вы пытаетесь пойти по неправильному маршруту, вы либо перенаправляетесь на 404, либо на основной маршрут. Кроме того, в файле <span class='code-block'>_app.tsx</span> для включения <span class='code-block'>i18n</span> приложение экспортируется с <span class='code-block'>appWithTranslation</span> оболочка:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"export default appWithTranslation(App);\"},{\"type\":\"paragraph\",\"content\":\"И последнее, но не менее важное — это файл <span class='code-block'>getStatic</span>, который отвечает за реквизиты страниц и получение языка.\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import { serverSideTranslations } from 'next-i18next/serverSideTranslations';\\n\\nimport i18nextConfig from '@i18config';\\n\\nexport const getI18nPaths = () =>\\n\\ti18nextConfig.i18n.locales.map((lang) => ({\\n\\t\\tparams: {\\n\\t\\t\\tlocale: lang\\n\\t\\t}\\n\\t}));\\n\\nexport const getStaticPaths = () => ({\\n\\tfallback: false,\\n\\tpaths: getI18nPaths()\\n});\\n\\nexport async function getI18nProps(ctx: any, ns = ['pages', 'components', 'errors', 'articles']) {\\n\\tconst locale = await ctx?.params?.locale;\\n\\tconst postName = await ctx?.params?.postName || null;\\n\\tconst projectName = await ctx?.params?.projectName || null;\\n\\n\\treturn {\\n\\t\\t...(await serverSideTranslations(locale, ns)),\\n\\t\\tlocale,\\n\\t\\tpostName,\\n\\t\\tprojectName\\n\\t};\\n}\\n\\n\\nexport function makeStaticProps(ns: string[]) {\\n\\treturn async function getStaticProps(ctx: any) {\\n\\t\\treturn {\\n\\t\\t\\tprops: await getI18nProps(ctx, ns)\\n\\t\\t};\\n\\t};\\n}\"},{\"type\":\"paragraph\",\"content\":\"Как видите, он возвращает <span class='code-block'>locale</span> и, при желании, <span class='code-block'>postName</span> или <span class='code-block '>projectName</span>. Это позволяет нам получить <span class='code-block'>locale</span> в свойствах и использовать его, например, в функции перенаправления.\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import { useTranslation } from 'next-i18next';\\nimport { getStaticPaths, makeStaticProps } from '@lib/getStatic';\\n\\ninterface ErrorPageProps {\\n\\tlocale: string;\\n}\\n\\nconst ErrorPage = ({ locale }: ErrorPageProps) => {\\n\\tconst { t } = useTranslation();\\n\\treturn (\\n\\t\\t<>...</>\\n\\t);\\n};\\n\\nconst getStaticProps = makeStaticProps();\\nexport { getStaticPaths, getStaticProps };\\n\\nexport default ErrorPage;\"},{\"type\":\"paragraph\",\"content\":\"Элементы в массиве для функции <span class='code-block'>makeStaticProps</span> имеют те же имена, что и файлы JSON внутри папки locale.\"},{\"type\":\"subtitle\",\"content\":\"Светлые/темные темы\"},{\"type\":\"paragraph\",\"content\":\"Здесь все достаточно легко. Просто <span class='code-block'>Recoil</span> для управления состоянием и localStorage для хранения значения цветовой схемы.\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"// src/store/global/global.state.ts\\n\\nimport { atom } from 'recoil';\\n\\nexport const theme = atom<'dark' | 'light'>({\\n\\tkey: 'theme',\\n\\tdefault: 'dark',\\n});\"},{\"type\":\"paragraph\",\"content\":\"Специальный хук для смены темы:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import { useMemo } from 'react';\\n\\nimport { useRecoilState } from 'recoil';\\n\\nimport { theme as storeTheme } from '@store/global/global.state';\\nimport { DarkTheme } from '@styles/Dark.theme';\\nimport { LightTheme } from '@styles/Light.theme';\\n\\nconst useDarkMode = () => {\\n\\tconst [theme, setTheme] = useRecoilState(storeTheme);\\n\\n\\tconst toggleTheme = () => {\\n\\t\\tsetTheme(theme === 'light' ? 'dark' : 'light');\\n\\t};\\n\\n\\tconst themeMode = useMemo(() => (theme === 'light' ? LightTheme : DarkTheme), [theme]);\\n\\n\\treturn [theme, toggleTheme, themeMode] as const;\\n};\\n\\nexport default useDarkMode;\"},{\"type\":\"paragraph\",\"content\":\"Используется в <span class='code-block'>Global.layout.tsx</span> от <span class='code-block'>ThemeProvider</span>:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import React from 'react';\\n\\nimport { ThemeProvider } from 'styled-components';\\n\\nimport useDarkMode from '@hooks/useDarkMode.hook';\\nimport { DarkTheme } from '@styles/Dark.theme';\\nimport { LightTheme } from '@styles/Light.theme';\\n\\nconst GlobalLayout = ({ children, loading = false }: GlobalLayoutProps) => {\\n\\tconst [theme] = useDarkMode();\\n\\n\\treturn (\\n\\t\\t<ThemeProvider theme={theme === 'light' ? LightTheme : DarkTheme}>\\n\\t\\t\\t...\\n\\t\\t</ThemeProvider>\\n\\t);\\n};\\n\\nexport default GlobalLayout;\"},{\"type\":\"paragraph\",\"content\":\"Обработчик смены темы реализован в компоненте <span class='code-block'>Header</span>.\"},{\"type\":\"paragraph\",\"content\":\"Две темы описаны в папке <span class='code-block'>themes</span>. Они реализуют интерфейс, который описывает, какие поля разрешено использовать:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"export interface ThemeProps {\\n\\tcolors: {\\n\\t\\tprimaryLight: string;\\n\\t\\tprimaryDark: string;\\n\\t\\tlightBackground: string;\\n\\t\\tdarkBackground: string;\\n\\t\\ttextColor: string;\\n\\t\\tsvgColor: string;\\n\\t}\\n}\"},{\"type\":\"subtitle\",\"content\":\"Рендеринг страницы\"},{\"type\":\"paragraph\",\"content\":\"Как видите, вместо создания страницы для каждого поста/проекта была создана только одна страница для каждого объекта. Каждая страница получает имя проекта или сообщения из параметров, а затем проверяет (в переменных среды) проверку, если страница существует, она отображает ее из JSON, в противном случае она перенаправляет пользователя на 404. Кроме того, это означает, что каждый JSON должен быть записаны в определенном формате:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import React from 'react';\\n\\nimport { useTranslation } from 'next-i18next';\\nimport { useRouter } from 'next/router';\\n\\nimport { makeStaticProps } from '@lib/getStatic';\\n\\ninterface PostProps {\\n\\tlocale: string;\\n\\tpostName: string;\\n}\\n\\nconst BlogPost = ({ locale, postName }: PostProps) => {\\n\\tconst { t } = useTranslation();\\n\\tconst router = useRouter();\\n  \\n\\treturn (\\n\\t\\t<>\\n\\t\\t\\t...\\n\\t\\t\\t<PostParagraph\\n\\t\\t\\t\\tdangerouslySetInnerHTML={{ __html: item }}\\n\\t\\t\\t/>\\n\\t\\t\\t...\\n\\t\\t</>\\n\\t);\\n};\\n\\nexport const getServerSideProps = async (ctx: any) => {\\n\\tconst staticProps = await makeStaticProps()(ctx);\\n\\tconst props = staticProps.props;\\n\\n\\treturn {\\n\\t\\tprops: {\\n\\t\\t\\t...props\\n\\t\\t}\\n\\t};\\n};\\n\\nexport default BlogPost;\"},{\"type\":\"paragraph\",\"content\":\"Как было сказано выше, использование props для поста и страницы проекта немного отличается от других страниц, так как в этом случае нам также нужно получить не только <span class='code-block'>locale</span>, но и <span class='code-block'>postName</span> (или <span class='code-block'>projectName</span>)\"},{\"type\":\"paragraph\",\"content\":\"Вы заметили <span class='code-block'>dangerouslySetInnerHTML</span>? Есть одна проблема с безопасностью...\"},{\"type\":\"title\",\"content\":\"Проблемы с безопасностью\"},{\"type\":\"paragraph\",\"content\":\"Блин, проблемы с безопасностью?! Да, наверное, вы заметили, что каждый пост в блоге пишется в формате JSON, просто указываются все поля и структура самого поста, такие как заголовки, субтитры, блоки кода и т. д. Ну, вот в игру вступает атака с внедрением XSS. Поскольку я хотел обернуть некоторый текст прямо внутри абзаца, например, <span class='code-block'>вот так</span>, мне нужно было решить, как я хочу это сделать.\"},{\"type\":\"paragraph\",\"content\":\"У меня было несколько идей по этому поводу, единственным требованием было то, что каждый пост должен быть в рамках \\\"одностраничной\\\" структуры. По сути, если вы посмотрите на файловую структуру, как уже упоминалось ранее, вы обнаружите, что есть только одна страница, которая получает имя сообщения из URL-адреса, а затем просто проверяет (используя переменные среды), существует ли страница, он \\\"рендерит\\\" его из JSON, иначе перенаправляет на страницу 404.\"},{\"type\":\"picture\",\"width\":\"w50\",\"resource\":\"readme1.png\"},{\"type\":\"paragraph\",\"content\":\"На данный момент, я думаю, некоторые из вас уже поняли, в чем проблема. Если мне нужно отобразить HTML, который написан как текст, мне нужно использовать <span class='code-block'>dangerouslySetInnerHTML</span>, и это прямая дорога к XSS, если текст поступает из ненадежных источников и/или не продезинфицирован.\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"<PostParagraph \\n\\tdangerouslySetInnerHTML={{ __html: item }}\\n/>\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"[\\n\\t\\\"Very last step here is checking if our nginx sever is working correctly\\\"\\n]\"},{\"type\":\"paragraph\",\"content\":\"Выше вы видели пример того, как я визуализирую простой абзац. Вы можете легко внедрить туда тег <span class='code-block'>script</span> и делать свои грязные дела. К счастью, есть только один источник, и он надежный, и это я :)\"},{\"type\":\"paragraph\",\"content\":\"Как я уже упоминал ранее, у меня было несколько идей, как это реализовать. То, как это было реализовано, на самом деле является самым простым. Другой довольно простой метод — простая санитарная обработка. Единственное, что будет исключено в этом случае, это тег <span class='code-block'>script</span>. Точно такая же ситуация со страницей проектов.\"},{\"type\":\"paragraph\",\"content\":\"Наиболее совершенным является создание \\\"ваших собственных тегов\\\", и после того, как страницы получат JSON, вместо того, чтобы отображать его в этот конкретный момент, вы передадите его функции, которая интерпретирует ваши теги в обычный HTML и вернет их на страницу. Кроме того, это будет своего рода дезинфекция, поскольку ее можно реализовать прямо в этой функции. Почему я поступил так? Ну... знаешь... я немного ленивый :)\"}]",
          created_at: new Date(),
          updated_at: new Date()
        },
        {
          id: uuid.v4(),
          language: 'pl',
          title: 'Blog osobisty',
          slug: 'personal-blog',
          brief: 'Jak jest skonstruowane to, co teraz czytasz',
          description: 'Aplikacja internetowa React + Next.js TypeScript do osobistego bloga i strony z portfolio. Miejsce, w którym dzielę się swoimi przemyśleniami i wiedzą.',
          search_tags: ["blog", "typescript", "nextjs"],
          tags: ["blog", "typescript", "nextjs"],
          brief_description: 'Być może zastanawiacie się, jak powstał ten blog od strony programistycznej, dlatego chciałem dać Wam krótki przegląd narzędzi i technologii, z których korzystałem.',
          license: 'MIT licencja',
          tech_stack: "[{\"src\":\"javascript\",\"width\":126,\"height\":28},{\"src\":\"typescript\",\"width\":126,\"height\":28},{\"src\":\"react\",\"width\":85,\"height\":28},{\"src\":\"next.js\",\"width\":85,\"height\":28},{\"src\":\"digitalOcean\",\"width\":130,\"height\":28},{\"src\":\"amazon-aws\",\"width\":74,\"height\":28},{\"src\":\"nginx\",\"width\":88,\"height\":28}]",
          project_pages: "[{\"link\":\"https://blog.mikhailbahdashych.me\",\"text\":\"blog.mikhailbahdashych.me\"},{\"link\":\"https://github.com/bl4drnnr/personal-blog\",\"text\":\"github.com/bl4drnnr/personal-blog\"}]",
          toc: "{\"Struktura i implementacja\":{\"multiLang\":\"Wielojęzykowość\",\"lightDarkThemes\":\"Jasne/Ciemne motywy\",\"pageRendering\":\"Renderowanie strony\"},\"secIssues\":\"Problemy z bezpieczeństwem\"}",
          content: "[{\"type\":\"title\",\"content\":\"Struktura i implementacja\"},{\"type\":\"paragraph\",\"content\":\"Myślę, że pierwszą rzeczą, którą musisz wiedzieć o blogu, jest to, że jest to najprostsza aplikacja statyczna. Mimo że nie ma żadnego API ani back-endu, z którego pobierane byłyby posty, nie zobaczysz strony struktury dla posta. W rzeczywistości strony są renderowane, ale z formatu JSON, co zostanie opisane później.\"},{\"type\":\"subtitle\",\"content\":\"Wielojęzykowość\"},{\"type\":\"paragraph\",\"content\":\"Przede wszystkim blog został napisany w 3 językach (nie programistycznych, lol) - polskim, angielskim i rosyjskim. Zostało to zaimplementowane przy użyciu biblioteki <span class='code-block'>i18n</span> (całkiem oczywiste, prawda).\"},{\"type\":\"paragraph\",\"content\":\"W katalogu głównym projektu znajdziesz prosty plik konfiguracyjny o nazwie <span class='code-block'>next-i18next.config.js</span> zawierający dostępne języki oraz języki domyślne:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"module.exports = {\\n\\ti18n: {\\n\\t\\tdefaultLocale: 'en',\\n\\t\\tlocales: ['en', 'pl', 'ru'],\\n  },\\n \\treact: { useSuspense: false }\\n};\"},{\"type\":\"paragraph\",\"content\":\"W folderze <span class='code-block'>lib</span> znajdziesz kilka funkcji odpowiedzialnych za cały proces tłumaczenia. Zostaną one omówione teraz, ale jest jeszcze jedna rzecz, o której należy wspomnieć.\"},{\"type\":\"paragraph\",\"content\":\"W folderze <span class='code-block'>locales</span> znajdziesz kilka innych folderów. Patrząc na ich nazwiska, można całkiem zrozumieć, za co są odpowiedzialni. Każdy folder ma te same nazwane pliki JSON (nawet taką samą strukturę), które zawierają cały tekst, który widzisz na blogu, przetłumaczony na 3 języki. Więc teraz wiesz, gdzie wszystko jest przechowywane, i możemy wrócić do folderu lib.\"},{\"type\":\"paragraph\",\"content\":\"Pierwszy to <span class='code-block'>language detector</span> zawiera to (<span class='code-block'>i18conifg</span> to alias dla <span class='code-block '>next-i18next.config.js</span>):\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import languageDetector from 'next-language-detector';\\n\\nimport i18nextConfig from '@i18config';\\n\\nexport default languageDetector({\\n\\tsupportedLngs: i18nextConfig.i18n.locales,\\n\\tfallbackLng: i18nextConfig.i18n.defaultLocale\\n});\"},{\"type\":\"paragraph\",\"content\":\"Powyższy kod jest tylko pomocnikiem dla <span class='code-block'>strony przekierowania</span>. To tylko pusta strona, która służy do sprawdzenia bieżącego języka:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import React from 'react';\\n\\nimport { useRouter } from 'next/router';\\n\\nimport languageDetector from './languageDetector';\\n\\nconst useRedirect = (to: any) => {\\n\\tconst router = useRouter();\\n\\tto = to || router.asPath;\\n\\n\\tReact.useEffect(() => {\\n\\t\\tconst detectedLng = languageDetector.detect();\\n\\t\\tif (to.startsWith('/' + detectedLng) && router.route === '/404') {\\n\\t\\t\\trouter.replace('/' + detectedLng + router.route);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// @ts-ignore\\n\\t\\tlanguageDetector.cache(detectedLng);\\n\\t\\trouter.replace('/' + detectedLng + to);\\n\\t});\\n\\n\\treturn <></>;\\n};\\n\\nexport const Redirect = () => {\\n\\t// @ts-ignore\\n\\tuseRedirect();\\n\\treturn <></>;\\n};\"},{\"type\":\"paragraph\",\"content\":\"Zapewne zauważyłeś, że trasa bloga zawsze wygląda tak: <span class='code-block'>blog.mikhailbahdashych.com/en</span>. Zawsze zaczyna się od wybranego języka. Zrozumiesz, dlaczego tak się dzieje, wystarczy spojrzeć na folder <span class='code-block'>pages</span>.\"},{\"type\":\"picture\",\"width\":\"w30\",\"resource\":\"readme2.png\"},{\"type\":\"paragraph\",\"content\":\"Treść każdej strony poza routem <span class='code-block'>[locale]</span> została zastąpiona przez:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import { Redirect } from '@lib/redirect';\\n\\nexport default Redirect;\"},{\"type\":\"paragraph\",\"content\":\"Dlatego za każdym razem, gdy próbujesz jechać na niewłaściwą trasę, jesteś albo przekierowywany na 404, albo na główną trasę. Ponadto w pliku <span class='code-block'>_app.tsx</span> w celu włączenia aplikacji <span class='code-block'>i18n</span> eksportowany jest kod <span class='code-block'>appWithTranslation</span>:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"export default appWithTranslation(App);\"},{\"type\":\"paragraph\",\"content\":\"Ostatnim, ale nie mniej ważnym elementem jest plik <span class='code-block'>getStatic</span>, który odpowiada za właściwości stron i pobieranie ustawień regionalnych.\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import { serverSideTranslations } from 'next-i18next/serverSideTranslations';\\n\\nimport i18nextConfig from '@i18config';\\n\\nexport const getI18nPaths = () =>\\n\\ti18nextConfig.i18n.locales.map((lang) => ({\\n\\t\\tparams: {\\n\\t\\t\\tlocale: lang\\n\\t\\t}\\n\\t}));\\n\\nexport const getStaticPaths = () => ({\\n\\tfallback: false,\\n\\tpaths: getI18nPaths()\\n});\\n\\nexport async function getI18nProps(ctx: any, ns = ['pages', 'components', 'errors', 'articles']) {\\n\\tconst locale = await ctx?.params?.locale;\\n\\tconst postName = await ctx?.params?.postName || null;\\n\\tconst projectName = await ctx?.params?.projectName || null;\\n\\n\\treturn {\\n\\t\\t...(await serverSideTranslations(locale, ns)),\\n\\t\\tlocale,\\n\\t\\tpostName,\\n\\t\\tprojectName\\n\\t};\\n}\\n\\n\\nexport function makeStaticProps(ns: string[]) {\\n\\treturn async function getStaticProps(ctx: any) {\\n\\t\\treturn {\\n\\t\\t\\tprops: await getI18nProps(ctx, ns)\\n\\t\\t};\\n\\t};\\n}\"},{\"type\":\"paragraph\",\"content\":\"Widać, że zwraca <span class='code-block'>locale</span> i opcjonalnie <span class='code-block'>postName</span> lub <span class='code-block'>nazwa projektu</span>. Pozwala nam pobrać <span class='code-block'>locale</span> w rekwizytach i użyć go na przykład w funkcji przekierowania.\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import { useTranslation } from 'next-i18next';\\nimport { getStaticPaths, makeStaticProps } from '@lib/getStatic';\\n\\ninterface ErrorPageProps {\\n\\tlocale: string;\\n}\\n\\nconst ErrorPage = ({ locale }: ErrorPageProps) => {\\n\\tconst { t } = useTranslation();\\n\\treturn (\\n\\t\\t<>...</>\\n\\t);\\n};\\n\\nconst getStaticProps = makeStaticProps();\\nexport { getStaticPaths, getStaticProps };\\n\\nexport default ErrorPage;\"},{\"type\":\"paragraph\",\"content\":\"Elementy w tablicy dla funkcji <span class='code-block'>makeStaticProps</span> mają dokładnie takie same nazwy jak pliki JSON w folderze ustawień regionalnych.\"},{\"type\":\"subtitle\",\"content\":\"Jasne/Ciemne motywy\"},{\"type\":\"paragraph\",\"content\":\"Tutaj wszystko jest dość łatwe. Wystarczy <span class='code-block'>Recoil</span>, aby kontrolować stan i localStorage, aby przechowywać wartość schematu kolorów.\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"// src/store/global/global.state.ts\\n\\nimport { atom } from 'recoil';\\n\\nexport const theme = atom<'dark' | 'light'>({\\n\\tkey: 'theme',\\n\\tdefault: 'dark',\\n});\"},{\"type\":\"paragraph\",\"content\":\"Specjalny haczyk do zmiany motywu:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import { useMemo } from 'react';\\n\\nimport { useRecoilState } from 'recoil';\\n\\nimport { theme as storeTheme } from '@store/global/global.state';\\nimport { DarkTheme } from '@styles/Dark.theme';\\nimport { LightTheme } from '@styles/Light.theme';\\n\\nconst useDarkMode = () => {\\n\\tconst [theme, setTheme] = useRecoilState(storeTheme);\\n\\n\\tconst toggleTheme = () => {\\n\\t\\tsetTheme(theme === 'light' ? 'dark' : 'light');\\n\\t};\\n\\n\\tconst themeMode = useMemo(() => (theme === 'light' ? LightTheme : DarkTheme), [theme]);\\n\\n\\treturn [theme, toggleTheme, themeMode] as const;\\n};\\n\\nexport default useDarkMode;\"},{\"type\":\"paragraph\",\"content\":\"Używany w <span class='code-block'>Global.layout.tsx</span> przez <span class='code-block'>ThemeProvider</span>:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import React from 'react';\\n\\nimport { ThemeProvider } from 'styled-components';\\n\\nimport useDarkMode from '@hooks/useDarkMode.hook';\\nimport { DarkTheme } from '@styles/Dark.theme';\\nimport { LightTheme } from '@styles/Light.theme';\\n\\nconst GlobalLayout = ({ children, loading = false }: GlobalLayoutProps) => {\\n\\tconst [theme] = useDarkMode();\\n\\n\\treturn (\\n\\t\\t<ThemeProvider theme={theme === 'light' ? LightTheme : DarkTheme}>\\n\\t\\t\\t...\\n\\t\\t</ThemeProvider>\\n\\t);\\n};\\n\\nexport default GlobalLayout;\"},{\"type\":\"paragraph\",\"content\":\"Moduł obsługi zmiany motywu został zaimplementowany w komponencie <span class='code-block'>Header</span>.\"},{\"type\":\"paragraph\",\"content\":\"Dwa motywy opisane w folderze <span class='code-block'>themes</span>. Implementują interfejs, który opisuje, jakie pola mogą być używane:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"export interface ThemeProps {\\n\\tcolors: {\\n\\t\\tprimaryLight: string;\\n\\t\\tprimaryDark: string;\\n\\t\\tlightBackground: string;\\n\\t\\tdarkBackground: string;\\n\\t\\ttextColor: string;\\n\\t\\tsvgColor: string;\\n\\t}\\n}\"},{\"type\":\"subtitle\",\"content\":\"Renderowanie strony\"},{\"type\":\"paragraph\",\"content\":\"Jak widać, zamiast tworzenia strony na post/projekt, utworzono tylko jedną stronę na encję. Każda strona pobiera nazwę projektu lub posta z params, a następnie sprawdza (w zmiennych środowiskowych) sprawdza, czy strona istnieje, renderuje ją z JSON, w innym przypadku przekierowuje użytkownika do 404. Oznacza to również, że każdy JSON musi być zapisane w określonym formacie.\"},{\"type\":\"paragraph\",\"content\":\"Oto jak to wygląda:\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"import React from 'react';\\n\\nimport { useTranslation } from 'next-i18next';\\nimport { useRouter } from 'next/router';\\n\\nimport { makeStaticProps } from '@lib/getStatic';\\n\\ninterface PostProps {\\n\\tlocale: string;\\n\\tpostName: string;\\n}\\n\\nconst BlogPost = ({ locale, postName }: PostProps) => {\\n\\tconst { t } = useTranslation();\\n\\tconst router = useRouter();\\n  \\n\\treturn (\\n\\t\\t<>\\n\\t\\t\\t...\\n\\t\\t\\t<PostParagraph\\n\\t\\t\\t\\tdangerouslySetInnerHTML={{ __html: item }}\\n\\t\\t\\t/>\\n\\t\\t\\t...\\n\\t\\t</>\\n\\t);\\n};\\n\\nexport const getServerSideProps = async (ctx: any) => {\\n\\tconst staticProps = await makeStaticProps()(ctx);\\n\\tconst props = staticProps.props;\\n\\n\\treturn {\\n\\t\\tprops: {\\n\\t\\t\\t...props\\n\\t\\t}\\n\\t};\\n};\\n\\nexport default BlogPost;\"},{\"type\":\"paragraph\",\"content\":\"Jak wspomniano powyżej, użycie rekwizytów dla strony postu i projektu różni się nieco od innych stron, ponieważ w tym przypadku musimy również uzyskać nie tylko <span class='code-block'>locale</span>, ale < span class='code-block'>postName</span> (lub <span class='code-block'>projectName</span>)\"},{\"type\":\"paragraph\",\"content\":\"Czy zauważyłeś <span class='code-block'>dangerouslySetInnerHTML</span>, cóż, jest jeden problem z bezpieczeństwem...\"},{\"type\":\"title\",\"content\":\"Problemy z bezpieczeństwem\"},{\"type\":\"paragraph\",\"content\":\"Bruh, problemy z bezpieczeństwem?! Tak, prawdopodobnie zauważyłeś, że każdy post na blogu jest napisany w formacie JSON, po prostu określając wszystkie pola i strukturę samego posta, takie jak tytuły, podtytuły, bloki kodu itp. Cóż, tutaj w grę wchodzi atak wstrzykiwania XSS. Ponieważ chciałem umieścić tekst bezpośrednio w akapicie, na przykład <span class='code-block'>w ten sposób</span>, musiałem zdecydować, jak chcę to zrobić.\"},{\"type\":\"paragraph\",\"content\":\"Miałem na to kilka pomysłów, jedynym wymogiem było to, aby każdy post mieścił się w strukturze \\\"jednej strony\\\". Zasadniczo, jeśli spojrzysz na strukturę plików, jak wspomniano wcześniej, przekonasz się, że jest tylko jedna strona, która pobiera nazwę posta z adresu URL, a następnie sprawdza (używając zmiennych środowiskowych), czy strona istnieje,\\\"renderuje\\\" go z JSON, w przeciwnym razie przekierowuje na stronę 404.\"},{\"type\":\"picture\",\"width\":\"w50\",\"resource\":\"readme1.png\"},{\"type\":\"paragraph\",\"content\":\"W tym momencie myślę, że niektórzy z was już zorientowali się, na czym polega problem. Jeśli muszę renderować HTML zapisany jako tekst, muszę użyć <span class='code-block'>dangerouslySetInnerHTML</span> i to jest prosta droga do XSS, jeśli tekst pochodzi z niezaufanych źródeł i/lub nie zdezynfekowane.\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"<PostParagraph \\n\\tdangerouslySetInnerHTML={{ __html: item }}\\n/>\"},{\"type\":\"code\",\"lang\":\"typescript\",\"content\":\"[\\n\\t\\\"Very last step here is checking if our nginx sever is working correctly\\\"\\n]\"},{\"type\":\"paragraph\",\"content\":\"Powyżej widzieliście przykład, jak renderuję prosty akapit. Możesz łatwo wstrzyknąć tam tag <span class='code-block'>script</span> i robić swoje brudne rzeczy. Na szczęście jest tylko jedno źródło i to zaufane, czyli ja :)\"},{\"type\":\"paragraph\",\"content\":\"Jak wspomniałem wcześniej, miałem kilka pomysłów, jak to wdrożyć. Sposób, w jaki został zaimplementowany, jest w rzeczywistości najłatwiejszy. Inną dość łatwą metodą jest prosta dezynfekcja. Jedyną rzeczą, która zostałaby wykluczona w tym przypadku, jest tag <span class='code-block'>script</span>. Dokładnie ta sama sytuacja ze stroną projektów.\"},{\"type\":\"paragraph\",\"content\":\"Najbardziej ukończone jest utworzenie \\\"własnych tagów\\\", a po tym, jak strony otrzymają JSON, zamiast renderować go dokładnie w tym momencie, przekazałbyś go do funkcji, która zinterpretowałaby twoje tagi do normalnego HTML i zwróciła je na stronę. Byłby to również rodzaj sanityzacji, ponieważ można go zaimplementować bezpośrednio w tej funkcji. Dlaczego postąpiłem w ten sposób? Cóż... Wiesz... Jestem trochę leniwy :)\"}]",
          created_at: new Date(),
          updated_at: new Date()
        }
      ]);
    } catch (e) {
      console.log(`Error while initiation of the database: ${e}`);
    }
  },

  async down(queryInterface) {
    await queryInterface.bulkDelete('posts', null, {});
    await queryInterface.bulkDelete('projects', null, {});
  }
};
